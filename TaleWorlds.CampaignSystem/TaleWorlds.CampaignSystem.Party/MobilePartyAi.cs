using System;
using System.Collections.Generic;
using Helpers;
using TaleWorlds.CampaignSystem.ComponentInterfaces;
using TaleWorlds.CampaignSystem.Map;
using TaleWorlds.CampaignSystem.MapEvents;
using TaleWorlds.CampaignSystem.Naval;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.LinQuick;
using TaleWorlds.SaveSystem;
using TaleWorlds.SaveSystem.Load;

namespace TaleWorlds.CampaignSystem.Party;

public class MobilePartyAi
{
	public class FleeingData
	{
		[SaveableField(1)]
		public bool AlreadyReachedTheDestinationWhileFleeing;

		[SaveableField(2)]
		public bool ShouldFleeClockWise;

		[SaveableField(3)]
		public bool CwFleeDirectionIsBlocked;

		[SaveableField(4)]
		public bool CcwFleeDirectionIsBlocked;

		internal static void AutoGeneratedStaticCollectObjectsFleeingData(object o, List<object> collectedObjects)
		{
			((FleeingData)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
		}

		internal static object AutoGeneratedGetMemberValueAlreadyReachedTheDestinationWhileFleeing(object o)
		{
			return ((FleeingData)o).AlreadyReachedTheDestinationWhileFleeing;
		}

		internal static object AutoGeneratedGetMemberValueShouldFleeClockWise(object o)
		{
			return ((FleeingData)o).ShouldFleeClockWise;
		}

		internal static object AutoGeneratedGetMemberValueCwFleeDirectionIsBlocked(object o)
		{
			return ((FleeingData)o).CwFleeDirectionIsBlocked;
		}

		internal static object AutoGeneratedGetMemberValueCcwFleeDirectionIsBlocked(object o)
		{
			return ((FleeingData)o).CcwFleeDirectionIsBlocked;
		}

		public void Clear()
		{
			AlreadyReachedTheDestinationWhileFleeing = false;
			ShouldFleeClockWise = false;
			CwFleeDirectionIsBlocked = false;
			CcwFleeDirectionIsBlocked = false;
		}
	}

	public static readonly List<(float, Vec2)> DangerousPartiesAndTheirVecs = new List<(float, Vec2)>();

	[SaveableField(33)]
	private FleeingData _fleeingData;

	[SaveableField(2)]
	private bool _isDisabled;

	[SaveableField(5)]
	private readonly MobileParty _mobileParty;

	[SaveableField(6)]
	public int HourCounter;

	[SaveableField(32)]
	internal CampaignVec2 BehaviorTarget;

	[SaveableField(13)]
	private float _attackInitiative = 1f;

	[SaveableField(14)]
	private float _avoidInitiative = 1f;

	[SaveableField(15)]
	private CampaignTime _initiativeRestoreTime;

	[SaveableField(18)]
	private CampaignTime _nextAiCheckTime;

	[SaveableField(19)]
	internal bool DefaultBehaviorNeedsUpdate;

	[SaveableField(30)]
	private IInteractablePoint _aiBehaviorInteractable;

	public bool IsDisabled
	{
		get
		{
			return _isDisabled;
		}
		private set
		{
			_isDisabled = value;
		}
	}

	[SaveableProperty(3)]
	private CampaignTime _enableAgainAtHour { get; set; }

	[SaveableProperty(10)]
	public bool RethinkAtNextHourlyTick { get; set; }

	[SaveableProperty(11)]
	public bool DoNotMakeNewDecisions { get; private set; }

	[SaveableProperty(17)]
	public bool IsAlerted { get; private set; }

	[SaveableProperty(31)]
	public CampaignTime DoNotAttackMainPartyUntil { get; internal set; }

	public float AvoidInitiative
	{
		get
		{
			if (!_initiativeRestoreTime.IsPast)
			{
				return _avoidInitiative;
			}
			return 1f;
		}
	}

	public float AttackInitiative
	{
		get
		{
			if (!_initiativeRestoreTime.IsPast)
			{
				return _attackInitiative;
			}
			return 1f;
		}
	}

	public PartyBase AiBehaviorPartyBase { get; private set; }

	public IInteractablePoint AiBehaviorInteractable
	{
		get
		{
			return _aiBehaviorInteractable;
		}
		set
		{
			if (_aiBehaviorInteractable == value)
			{
				return;
			}
			_aiBehaviorInteractable = value;
			AiBehaviorPartyBase = null;
			if (_aiBehaviorInteractable != null)
			{
				if (_aiBehaviorInteractable is PartyBase aiBehaviorPartyBase)
				{
					AiBehaviorPartyBase = aiBehaviorPartyBase;
				}
			}
			else
			{
				AiBehaviorPartyBase = null;
			}
		}
	}

	internal static void AutoGeneratedStaticCollectObjectsMobilePartyAi(object o, List<object> collectedObjects)
	{
		((MobilePartyAi)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		CampaignVec2.AutoGeneratedStaticCollectObjectsCampaignVec2(BehaviorTarget, collectedObjects);
		collectedObjects.Add(_fleeingData);
		collectedObjects.Add(_mobileParty);
		CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(_initiativeRestoreTime, collectedObjects);
		CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(_nextAiCheckTime, collectedObjects);
		collectedObjects.Add(_aiBehaviorInteractable);
		CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(_enableAgainAtHour, collectedObjects);
		CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime(DoNotAttackMainPartyUntil, collectedObjects);
	}

	internal static object AutoGeneratedGetMemberValue_enableAgainAtHour(object o)
	{
		return ((MobilePartyAi)o)._enableAgainAtHour;
	}

	internal static object AutoGeneratedGetMemberValueRethinkAtNextHourlyTick(object o)
	{
		return ((MobilePartyAi)o).RethinkAtNextHourlyTick;
	}

	internal static object AutoGeneratedGetMemberValueDoNotMakeNewDecisions(object o)
	{
		return ((MobilePartyAi)o).DoNotMakeNewDecisions;
	}

	internal static object AutoGeneratedGetMemberValueIsAlerted(object o)
	{
		return ((MobilePartyAi)o).IsAlerted;
	}

	internal static object AutoGeneratedGetMemberValueDoNotAttackMainPartyUntil(object o)
	{
		return ((MobilePartyAi)o).DoNotAttackMainPartyUntil;
	}

	internal static object AutoGeneratedGetMemberValueHourCounter(object o)
	{
		return ((MobilePartyAi)o).HourCounter;
	}

	internal static object AutoGeneratedGetMemberValueBehaviorTarget(object o)
	{
		return ((MobilePartyAi)o).BehaviorTarget;
	}

	internal static object AutoGeneratedGetMemberValueDefaultBehaviorNeedsUpdate(object o)
	{
		return ((MobilePartyAi)o).DefaultBehaviorNeedsUpdate;
	}

	internal static object AutoGeneratedGetMemberValue_fleeingData(object o)
	{
		return ((MobilePartyAi)o)._fleeingData;
	}

	internal static object AutoGeneratedGetMemberValue_isDisabled(object o)
	{
		return ((MobilePartyAi)o)._isDisabled;
	}

	internal static object AutoGeneratedGetMemberValue_mobileParty(object o)
	{
		return ((MobilePartyAi)o)._mobileParty;
	}

	internal static object AutoGeneratedGetMemberValue_attackInitiative(object o)
	{
		return ((MobilePartyAi)o)._attackInitiative;
	}

	internal static object AutoGeneratedGetMemberValue_avoidInitiative(object o)
	{
		return ((MobilePartyAi)o)._avoidInitiative;
	}

	internal static object AutoGeneratedGetMemberValue_initiativeRestoreTime(object o)
	{
		return ((MobilePartyAi)o)._initiativeRestoreTime;
	}

	internal static object AutoGeneratedGetMemberValue_nextAiCheckTime(object o)
	{
		return ((MobilePartyAi)o)._nextAiCheckTime;
	}

	internal static object AutoGeneratedGetMemberValue_aiBehaviorInteractable(object o)
	{
		return ((MobilePartyAi)o)._aiBehaviorInteractable;
	}

	internal MobilePartyAi(MobileParty mobileParty)
	{
		_mobileParty = mobileParty;
		RethinkAtNextHourlyTick = false;
		HourCounter = MBRandom.RandomInt(100);
		_fleeingData = new FleeingData();
	}

	internal void PreAfterLoad()
	{
		CacheAiBehaviorPartyBase();
		if (MBSaveLoad.LastLoadedGameVersion.IsOlderThan(ApplicationVersion.FromString("v1.3.0")) && _mobileParty.ShortTermBehavior == AiBehavior.FleeToGate)
		{
			CampaignVec2 campaignVec = CampaignVec2.Normalized(_mobileParty.ShortTermTargetParty.Position - _mobileParty.Position);
			GetBehaviorForNearbySettlementToFlee(_mobileParty.ShortTermTargetParty, campaignVec.ToVec2(), out var fleeSettlement, out var targetPoint, out var aiBehavior);
			SetAiBehavior(aiBehavior, fleeSettlement?.Party, targetPoint);
		}
	}

	public void CacheAiBehaviorPartyBase()
	{
		if (AiBehaviorInteractable != null && AiBehaviorInteractable is PartyBase aiBehaviorPartyBase)
		{
			AiBehaviorPartyBase = aiBehaviorPartyBase;
		}
	}

	internal void Tick(float dt)
	{
		if (DefaultBehaviorNeedsUpdate)
		{
			_nextAiCheckTime = CampaignTime.Now;
			DefaultBehaviorNeedsUpdate = false;
		}
		if (!_nextAiCheckTime.IsFuture)
		{
			TickInternal();
			float num = Campaign.Current.Models.MobilePartyAIModel.AiCheckInterval * (0.6f + 0.1f * MBRandom.RandomFloat);
			num *= ((_mobileParty.ShortTermTargetParty == MobileParty.MainParty && _mobileParty.ShortTermBehavior == AiBehavior.EngageParty) ? 0.5f : 1f);
			if (_mobileParty.IsFleeing())
			{
				num *= ((_mobileParty.ShortTermTargetParty == MobileParty.MainParty) ? 0.5f : 0.75f);
				num *= (_mobileParty.IsBandit ? 10f : 1f);
				num *= ((!_mobileParty.IsBandit && _fleeingData.CcwFleeDirectionIsBlocked && _fleeingData.CwFleeDirectionIsBlocked) ? 15f : 1f);
			}
			num *= ((_mobileParty.SiegeEvent != null) ? 2f : 1f);
			long valueInSeconds = (long)(num * (float)CampaignTime.MinutesInHour * (float)CampaignTime.SecondsInMinute);
			_nextAiCheckTime = CampaignTime.Now + CampaignTime.Seconds(valueInSeconds);
		}
	}

	[LateLoadInitializationCallback]
	private void OnLateLoad(MetaData metaData, ObjectLoadData objectLoadData)
	{
		if (MBSaveLoad.LastLoadedGameVersion < ApplicationVersion.FromString("v1.3.0"))
		{
			object memberValueBySaveId = objectLoadData.GetMemberValueBySaveId(30);
			if (memberValueBySaveId != null)
			{
				if (memberValueBySaveId is MobileParty mobileParty)
				{
					AiBehaviorInteractable = mobileParty.Party;
				}
				else if (memberValueBySaveId is Settlement settlement)
				{
					AiBehaviorInteractable = settlement.Party;
				}
			}
		}
		if (MBSaveLoad.IsUpdatingGameVersion && MBSaveLoad.LastLoadedGameVersion.IsOlderThan(ApplicationVersion.FromString("v1.3.0")))
		{
			object memberValueBySaveId2 = objectLoadData.GetMemberValueBySaveId(20);
			int numberOfRecentFleeingFromAParty = 0;
			if (memberValueBySaveId2 != null)
			{
				numberOfRecentFleeingFromAParty = (int)memberValueBySaveId2;
			}
			object memberValueBySaveId3 = objectLoadData.GetMemberValueBySaveId(21);
			AiBehavior defaultBehavior = AiBehavior.Hold;
			if (memberValueBySaveId3 != null)
			{
				defaultBehavior = (AiBehavior)memberValueBySaveId3;
			}
			object memberValueBySaveId4 = objectLoadData.GetMemberValueBySaveId(22);
			bool aiPathMode = false;
			if (memberValueBySaveId4 != null)
			{
				aiPathMode = (bool)memberValueBySaveId4;
			}
			object memberValueBySaveId5 = objectLoadData.GetMemberValueBySaveId(24);
			MoveModeType partyMoveMode = MoveModeType.Hold;
			if (memberValueBySaveId5 != null)
			{
				partyMoveMode = (MoveModeType)memberValueBySaveId5;
			}
			object memberValueBySaveId6 = objectLoadData.GetMemberValueBySaveId(25);
			Vec2 formationPosition = Vec2.Zero;
			if (memberValueBySaveId6 != null)
			{
				formationPosition = (Vec2)memberValueBySaveId6;
			}
			object memberValueBySaveId7 = objectLoadData.GetMemberValueBySaveId(26);
			MobileParty moveTargetParty = null;
			if (memberValueBySaveId7 != null)
			{
				moveTargetParty = (MobileParty)memberValueBySaveId7;
			}
			object memberValueBySaveId8 = objectLoadData.GetMemberValueBySaveId(27);
			Vec2 nextTargetPosition = Vec2.Zero;
			if (memberValueBySaveId8 != null)
			{
				nextTargetPosition = (Vec2)memberValueBySaveId8;
			}
			object memberValueBySaveId9 = objectLoadData.GetMemberValueBySaveId(28);
			Vec2 moveTargetPoint = Vec2.Zero;
			if (memberValueBySaveId9 != null)
			{
				moveTargetPoint = (Vec2)memberValueBySaveId9;
			}
			object memberValueBySaveId10 = objectLoadData.GetMemberValueBySaveId(29);
			Vec2 aiPathLastPosition = Vec2.Zero;
			if (memberValueBySaveId10 != null)
			{
				aiPathLastPosition = (Vec2)memberValueBySaveId10;
			}
			_mobileParty.InitializePartyForOldSave(numberOfRecentFleeingFromAParty, defaultBehavior, aiPathMode, partyMoveMode, formationPosition, moveTargetParty, nextTargetPosition, moveTargetPoint, aiPathLastPosition);
		}
		if (MBSaveLoad.IsUpdatingGameVersion && MBSaveLoad.LastLoadedGameVersion.IsOlderThan(ApplicationVersion.FromString("v1.3.0")))
		{
			object memberValueBySaveId11 = objectLoadData.GetMemberValueBySaveId(12);
			Vec2 pos = Vec2.Zero;
			if (memberValueBySaveId11 != null)
			{
				pos = (Vec2)memberValueBySaveId11;
			}
			BehaviorTarget = new CampaignVec2(pos, isOnLand: true);
		}
		if (MBSaveLoad.IsUpdatingGameVersion && MBSaveLoad.LastLoadedGameVersion.IsOlderThan(ApplicationVersion.FromString("v1.3.0")) && _fleeingData == null)
		{
			_fleeingData = new FleeingData();
		}
	}

	private void TickInternal()
	{
		if (_mobileParty.MapEvent != null || !_mobileParty.IsActive)
		{
			return;
		}
		if (_mobileParty == MobileParty.MainParty && MobileParty.MainParty.DefaultBehavior == AiBehavior.EngageParty && !MobileParty.MainParty.TargetParty.IsVisible)
		{
			MobileParty.MainParty.SetMoveModeHold();
		}
		if (IsDisabled)
		{
			if (EnableAgainAtHourIsPast())
			{
				EnableAi();
			}
		}
		else if (_mobileParty.Army == null || !_mobileParty.Army.LeaderParty.AttachedParties.Contains(_mobileParty))
		{
			GetBehaviors(out var bestAiBehavior, out var behaviorObject, out var bestTargetPoint);
			SetAiBehavior(bestAiBehavior, behaviorObject, bestTargetPoint);
		}
	}

	private void GetBestMoveToNearestLandBehavior(out AiBehavior shortTermBehavior, out CampaignVec2 shortTermTargetPoint, out Settlement shortTermTargetSettlement)
	{
		shortTermTargetSettlement = null;
		if (_mobileParty.HasLandNavigationCapability)
		{
			shortTermBehavior = AiBehavior.GoToPoint;
			int[] invalidTerrainTypesForNavigationType = Campaign.Current.Models.PartyNavigationModel.GetInvalidTerrainTypesForNavigationType(MobileParty.NavigationType.All);
			shortTermTargetPoint = Campaign.Current.MapSceneWrapper.GetNearestFaceCenterForPositionWithPath(_mobileParty.CurrentNavigationFace, targetIsLand: true, Campaign.MapDiagonal / 2f, invalidTerrainTypesForNavigationType);
		}
		else
		{
			shortTermBehavior = AiBehavior.GoToSettlement;
			shortTermTargetPoint = _mobileParty.TargetSettlement.PortPosition;
			shortTermTargetSettlement = _mobileParty.TargetSettlement;
		}
	}

	public void CheckPartyNeedsUpdate()
	{
		if (DefaultBehaviorNeedsUpdate)
		{
			Tick(0f);
			EncounterManager.HandleEncounterForMobileParty(_mobileParty, 0f);
		}
	}

	internal void GetBehaviors(out AiBehavior bestAiBehavior, out IInteractablePoint behaviorObject, out CampaignVec2 bestTargetPoint)
	{
		bestAiBehavior = _mobileParty.DefaultBehavior;
		MobileParty mobileParty = _mobileParty.TargetParty ?? _mobileParty.ShortTermTargetParty;
		bestTargetPoint = _mobileParty.TargetPosition;
		Vec2 averageEnemyVec = new Vec2(0f, 0f);
		if (Campaign.Current.GameStarted && Campaign.Current.Models.MobilePartyAIModel.ShouldPartyCheckInitiativeBehavior(_mobileParty))
		{
			Campaign.Current.Models.MobilePartyAIModel.GetBestInitiativeBehavior(_mobileParty, out var bestInitiativeBehavior, out var bestInitiativeTargetParty, out var bestInitiativeBehaviorScore, out averageEnemyVec);
			if (!DoNotMakeNewDecisions || (bestInitiativeTargetParty != null && _mobileParty.TargetSettlement != null && ((bestInitiativeTargetParty.MapEvent != null && bestInitiativeTargetParty.MapEvent.MapEventSettlement == _mobileParty.TargetSettlement) || bestInitiativeTargetParty.BesiegedSettlement == _mobileParty.TargetSettlement)))
			{
				if (bestInitiativeBehaviorScore > 1f && (_mobileParty.DefaultBehavior != AiBehavior.DefendSettlement || bestInitiativeTargetParty != _mobileParty.TargetSettlement.LastAttackerParty))
				{
					bestAiBehavior = bestInitiativeBehavior;
					mobileParty = bestInitiativeTargetParty;
					if (bestInitiativeBehavior == AiBehavior.EngageParty && bestInitiativeTargetParty.IsCurrentlyAtSea != _mobileParty.IsCurrentlyAtSea && !_mobileParty.IsTransitionInProgress)
					{
						_mobileParty.StartTransitionNextFrameToExitFromPort = true;
					}
				}
				else if (MobileParty.IsFleeBehavior(bestInitiativeBehavior) && MobileParty.IsFleeBehavior(_mobileParty.ShortTermBehavior))
				{
					float num = _mobileParty.AiBehaviorTarget.DistanceSquared(_mobileParty.Position);
					float lastCalculatedSpeed = _mobileParty._lastCalculatedSpeed;
					if (num >= lastCalculatedSpeed * lastCalculatedSpeed * Campaign.Current.Models.MobilePartyAIModel.AiCheckInterval * Campaign.Current.Models.MobilePartyAIModel.AiCheckInterval)
					{
						bestAiBehavior = _mobileParty.ShortTermBehavior;
						mobileParty = ((_mobileParty.ShortTermBehavior != AiBehavior.FleeToGate) ? (_mobileParty.ShortTermTargetParty ?? bestInitiativeTargetParty) : (_mobileParty.TargetParty ?? bestInitiativeTargetParty));
					}
				}
				if (MobileParty.IsFleeBehavior(_mobileParty.ShortTermBehavior) && !MobileParty.IsFleeBehavior(bestAiBehavior))
				{
					_fleeingData.Clear();
				}
				if (bestInitiativeBehavior == AiBehavior.DefendSettlement && bestInitiativeTargetParty.DefaultBehavior == AiBehavior.DefendSettlement && bestInitiativeTargetParty.MapEvent != null)
				{
					bestAiBehavior = AiBehavior.EngageParty;
					mobileParty = bestInitiativeTargetParty.ShortTermTargetParty;
				}
			}
		}
		IsAlerted = false;
		AiBehavior shortTermBehavior = bestAiBehavior;
		CampaignVec2 shortTermTargetPoint = bestTargetPoint;
		Settlement shortTermTargetSettlement = _mobileParty.TargetSettlement;
		MobileParty shortTermTargetParty = mobileParty;
		switch (bestAiBehavior)
		{
		case AiBehavior.GoAroundParty:
			shortTermTargetParty = _mobileParty.TargetParty;
			GetGoAroundPartyBehavior(_mobileParty.TargetParty, out shortTermBehavior, out shortTermTargetPoint);
			break;
		case AiBehavior.EngageParty:
			shortTermTargetPoint = shortTermTargetParty.Position;
			if (shortTermTargetParty.SiegeEvent != null && _mobileParty.IsCurrentlyAtSea && _mobileParty.IsTargetingPort)
			{
				shortTermTargetPoint = shortTermTargetSettlement.PortPosition;
				shortTermBehavior = AiBehavior.GoToSettlement;
				_mobileParty.SetShortTermBehavior(AiBehavior.GoToSettlement, shortTermTargetParty.SiegeEvent.BesiegedSettlement.Party);
			}
			else
			{
				_mobileParty.SetShortTermBehavior(AiBehavior.EngageParty, shortTermTargetParty.Party);
			}
			break;
		case AiBehavior.PatrolAroundPoint:
		{
			bool forceUpdate = _mobileParty.ShortTermBehavior == AiBehavior.FleeToPoint || (!_mobileParty.IsTransitionInProgress && shortTermTargetPoint.IsOnLand == _mobileParty.IsCurrentlyAtSea) || _mobileParty.TargetPosition == _mobileParty.MoveTargetPoint;
			if (shortTermTargetPoint.IsOnLand)
			{
				GetLandPatrolBehavior(out shortTermBehavior, out shortTermTargetPoint, _mobileParty.TargetPosition, forceUpdate);
			}
			else
			{
				GetNavalPatrolBehavior(out shortTermBehavior, out shortTermTargetPoint, _mobileParty.TargetPosition, forceUpdate);
			}
			shortTermTargetParty = null;
			_mobileParty.SetShortTermBehavior(AiBehavior.GoToPoint, null);
			break;
		}
		case AiBehavior.FleeToPoint:
		case AiBehavior.FleeToGate:
		case AiBehavior.FleeToParty:
			IsAlerted = true;
			GetFleeBehavior(out shortTermBehavior, out shortTermTargetPoint, ref shortTermTargetSettlement, mobileParty, averageEnemyVec);
			break;
		case AiBehavior.EscortParty:
			GetFollowBehavior(ref shortTermBehavior, ref shortTermTargetSettlement, mobileParty, out shortTermTargetPoint);
			break;
		case AiBehavior.BesiegeSettlement:
			if (!_mobileParty.IsMainParty)
			{
				GetBesiegeBehavior(out shortTermBehavior, out shortTermTargetPoint, out shortTermTargetSettlement);
			}
			break;
		case AiBehavior.GoToSettlement:
			if (_mobileParty.CurrentSettlement == _mobileParty.TargetSettlement)
			{
				GetInSettlementBehavior(ref shortTermBehavior, ref shortTermTargetParty);
				shortTermTargetPoint = shortTermTargetParty?.Position ?? _mobileParty.Position;
			}
			break;
		case AiBehavior.DefendSettlement:
		{
			Settlement targetSettlement = _mobileParty.TargetSettlement;
			if (targetSettlement == null)
			{
				targetSettlement = mobileParty.TargetSettlement;
			}
			if (targetSettlement.LastAttackerParty != null && targetSettlement.LastAttackerParty.IsActive)
			{
				GetDefendSettlementBehavior(targetSettlement, out shortTermBehavior, out shortTermTargetPoint, out shortTermTargetParty);
				break;
			}
			shortTermBehavior = AiBehavior.GoToPoint;
			shortTermTargetPoint = ((_mobileParty.IsCurrentlyAtSea && targetSettlement.HasPort) ? targetSettlement.PortPosition : targetSettlement.GatePosition);
			break;
		}
		case AiBehavior.MoveToNearestLandOrPort:
			GetBestMoveToNearestLandBehavior(out shortTermBehavior, out shortTermTargetPoint, out shortTermTargetSettlement);
			break;
		}
		bestAiBehavior = shortTermBehavior;
		bestTargetPoint = shortTermTargetPoint;
		_ = bestTargetPoint.Face;
		if (shortTermTargetParty != null)
		{
			mobileParty = shortTermTargetParty;
		}
		if (bestAiBehavior == AiBehavior.GoToSettlement || bestAiBehavior == AiBehavior.RaidSettlement || bestAiBehavior == AiBehavior.AssaultSettlement || bestAiBehavior == AiBehavior.BesiegeSettlement || (bestAiBehavior == AiBehavior.DefendSettlement && mobileParty == null))
		{
			behaviorObject = ((shortTermTargetSettlement != null) ? shortTermTargetSettlement.Party : _mobileParty.TargetSettlement.Party);
		}
		else if (bestAiBehavior == AiBehavior.EngageParty || bestAiBehavior == AiBehavior.FleeToParty || bestAiBehavior == AiBehavior.GoAroundParty || bestAiBehavior == AiBehavior.EscortParty || bestAiBehavior == AiBehavior.JoinParty || bestAiBehavior == AiBehavior.FleeToPoint || (bestAiBehavior == AiBehavior.DefendSettlement && mobileParty != null))
		{
			behaviorObject = mobileParty?.Party;
		}
		else if (bestAiBehavior == AiBehavior.FleeToGate)
		{
			behaviorObject = shortTermTargetSettlement?.Party ?? _mobileParty.ShortTermTargetSettlement.Party;
		}
		else if (bestAiBehavior == AiBehavior.MoveToNearestLandOrPort)
		{
			behaviorObject = _mobileParty.Ai.AiBehaviorInteractable;
		}
		else if (bestAiBehavior == AiBehavior.Hold || bestAiBehavior == AiBehavior.None)
		{
			behaviorObject = null;
		}
		else if (bestAiBehavior == AiBehavior.GoToPoint)
		{
			IInteractablePoint interactablePoint;
			if (shortTermTargetParty == null)
			{
				interactablePoint = AiBehaviorInteractable;
			}
			else
			{
				IInteractablePoint party = shortTermTargetParty.Party;
				interactablePoint = party;
			}
			behaviorObject = interactablePoint;
		}
		else if (bestAiBehavior == AiBehavior.DoOperation)
		{
			Debug.FailedAssert("DoOperation", "C:\\BuildAgent\\work\\mb3\\Source\\Bannerlord\\TaleWorlds.CampaignSystem\\Party\\MobilePartyAi.cs", "GetBehaviors", 643);
			behaviorObject = null;
		}
		else
		{
			behaviorObject = AiBehaviorInteractable;
		}
	}

	private void GetInSettlementBehavior(ref AiBehavior shortTermBehavior, ref MobileParty shortTermTargetParty)
	{
		shortTermTargetParty = null;
		if (_mobileParty.MapEvent != null)
		{
			MobileParty mobileParty = _mobileParty.MapEvent.AttackerSide.LeaderParty.MobileParty;
			if (FactionManager.IsAtWarAgainstFaction(mobileParty.MapFaction, _mobileParty.MapFaction))
			{
				shortTermBehavior = AiBehavior.EngageParty;
				shortTermTargetParty = mobileParty;
			}
		}
	}

	private void GetFollowBehavior(ref AiBehavior shortTermBehavior, ref Settlement shortTermTargetSettlement, MobileParty followedParty, out CampaignVec2 shortTermTargetPoint)
	{
		shortTermBehavior = AiBehavior.EscortParty;
		if (followedParty == null || !followedParty.IsActive)
		{
			shortTermBehavior = AiBehavior.Hold;
			shortTermTargetPoint = _mobileParty.Position;
			return;
		}
		if (followedParty.CurrentSettlement != null)
		{
			shortTermBehavior = AiBehavior.GoToSettlement;
			shortTermTargetSettlement = followedParty.CurrentSettlement;
			shortTermTargetPoint = (_mobileParty.IsTargetingPort ? followedParty.CurrentSettlement.PortPosition : followedParty.CurrentSettlement.GatePosition);
			return;
		}
		shortTermTargetPoint = followedParty.Position;
		if (followedParty.IsCurrentlyAtSea && !_mobileParty.HasNavalNavigationCapability)
		{
			CampaignVec2 moveTargetPoint = _mobileParty.MoveTargetPoint;
			if (DistanceHelper.FindClosestDistanceFromMobilePartyToPoint(_mobileParty, moveTargetPoint, _mobileParty.NavigationCapability) > Campaign.MapDiagonal)
			{
				shortTermBehavior = AiBehavior.Hold;
				shortTermTargetPoint = _mobileParty.Position;
			}
			else
			{
				shortTermBehavior = AiBehavior.GoToPoint;
				shortTermTargetPoint = _mobileParty.MoveTargetPoint;
			}
		}
		else
		{
			shortTermBehavior = AiBehavior.GoToPoint;
			if (_mobileParty.IsTransitionInProgress && ((_mobileParty.IsCurrentlyAtSea && !followedParty.IsCurrentlyAtSea && _mobileParty.HasLandNavigationCapability) || (!_mobileParty.IsCurrentlyAtSea && followedParty.IsCurrentlyAtSea && _mobileParty.HasNavalNavigationCapability)))
			{
				shortTermTargetPoint = _mobileParty.EndPositionForNavigationTransition;
			}
			else
			{
				shortTermTargetPoint = followedParty.Position;
			}
		}
	}

	private void GetBesiegeBehavior(out AiBehavior shortTermBehavior, out CampaignVec2 shortTermTargetPoint, out Settlement shortTermTargetSettlement)
	{
		if (_mobileParty.TargetSettlement != null)
		{
			if (_mobileParty.TargetSettlement.SiegeEvent != null && _mobileParty.TargetSettlement.SiegeEvent.BesiegerCamp.LeaderParty == _mobileParty && _mobileParty.TargetSettlement.SiegeEvent.BesiegerCamp.IsReadyToBesiege)
			{
				shortTermTargetSettlement = _mobileParty.TargetSettlement;
				shortTermBehavior = AiBehavior.AssaultSettlement;
			}
			else if (_mobileParty.BesiegedSettlement == _mobileParty.TargetSettlement)
			{
				shortTermTargetSettlement = null;
				shortTermBehavior = AiBehavior.Hold;
			}
			else
			{
				shortTermTargetSettlement = _mobileParty.TargetSettlement;
				shortTermBehavior = AiBehavior.GoToSettlement;
			}
		}
		else
		{
			shortTermTargetSettlement = null;
			shortTermBehavior = AiBehavior.GoToPoint;
		}
		shortTermTargetPoint = _mobileParty.TargetSettlement.GatePosition;
	}

	private void GetFleeBehavior(out AiBehavior fleeBehaviorInternal, out CampaignVec2 fleeTargetPoint, ref Settlement fleeTargetSettlement, MobileParty partyToFleeFrom, Vec2 avarageEnemyVec)
	{
		fleeBehaviorInternal = _mobileParty.ShortTermBehavior;
		fleeTargetPoint = _mobileParty.AiBehaviorTarget;
		if (_mobileParty.CurrentSettlement != null && (partyToFleeFrom == null || partyToFleeFrom.CurrentSettlement != _mobileParty.CurrentSettlement))
		{
			fleeBehaviorInternal = AiBehavior.GoToSettlement;
			fleeTargetSettlement = _mobileParty.CurrentSettlement;
			fleeTargetPoint = (_mobileParty.IsCurrentlyAtSea ? fleeTargetSettlement.PortPosition : fleeTargetSettlement.GatePosition);
		}
		else if (partyToFleeFrom != null && _mobileParty.DefaultBehavior == AiBehavior.GoToSettlement && ((partyToFleeFrom.MapEvent != null && partyToFleeFrom.MapEvent.MapEventSettlement == _mobileParty.TargetSettlement) || partyToFleeFrom.BesiegedSettlement == _mobileParty.TargetSettlement))
		{
			fleeBehaviorInternal = AiBehavior.FleeToPoint;
			fleeTargetPoint = _mobileParty.Position;
		}
		else
		{
			fleeBehaviorInternal = AiBehavior.FleeToPoint;
			fleeTargetPoint = _mobileParty.Position;
			if (partyToFleeFrom != null && _mobileParty.DefaultBehavior == AiBehavior.PatrolAroundPoint && partyToFleeFrom.Position.DistanceSquared(_mobileParty.TargetPosition.ToVec2()) < 4f)
			{
				if (partyToFleeFrom.IsMoving || partyToFleeFrom.IsGarrison)
				{
					if (!_mobileParty.TargetPosition.IsOnLand)
					{
						GetNavalPatrolBehavior(out fleeBehaviorInternal, out fleeTargetPoint, _mobileParty.TargetPosition, forceUpdate: true);
					}
					else
					{
						GetLandPatrolBehavior(out fleeBehaviorInternal, out fleeTargetPoint, _mobileParty.TargetPosition, forceUpdate: true);
					}
				}
				else
				{
					fleeBehaviorInternal = AiBehavior.Hold;
					fleeTargetPoint = _mobileParty.Position;
				}
			}
			else
			{
				CalculateFleePosition(out fleeTargetPoint, partyToFleeFrom, avarageEnemyVec);
			}
		}
		Vec2 fleeDirection = fleeTargetPoint.ToVec2() - _mobileParty.Position.ToVec2();
		fleeDirection.Normalize();
		bool flag = _mobileParty.IsLordParty || _mobileParty.IsCaravan || _mobileParty.IsVillager;
		if (partyToFleeFrom != null && flag)
		{
			MobileParty nearbyPartyToFlee = GetNearbyPartyToFlee(partyToFleeFrom, fleeDirection);
			if (nearbyPartyToFlee != null)
			{
				fleeBehaviorInternal = AiBehavior.FleeToParty;
				fleeTargetPoint = nearbyPartyToFlee.Position;
			}
		}
		if (flag && _mobileParty.MapFaction.IsKingdomFaction && partyToFleeFrom != null && partyToFleeFrom.MapEvent == null && partyToFleeFrom.SiegeEvent == null)
		{
			GetBehaviorForNearbySettlementToFlee(partyToFleeFrom, fleeDirection, out fleeTargetSettlement, out var targetPoint, out fleeBehaviorInternal);
			if (fleeTargetSettlement != null)
			{
				fleeTargetPoint = targetPoint;
				_fleeingData.CcwFleeDirectionIsBlocked = true;
				_fleeingData.CwFleeDirectionIsBlocked = true;
			}
		}
	}

	public void CalculateFleePosition(out CampaignVec2 fleeTargetPoint, MobileParty partyToFleeFrom, Vec2 averageEnemyVec)
	{
		if (_fleeingData.CcwFleeDirectionIsBlocked && _fleeingData.CwFleeDirectionIsBlocked)
		{
			_fleeingData.Clear();
		}
		float num = ((partyToFleeFrom != null && partyToFleeFrom.Army != null) ? Campaign.Current.Models.EncounterModel.MaximumAllowedDistanceForEncounteringMobilePartyInArmy : Campaign.Current.Models.EncounterModel.NeededMaximumDistanceForEncounteringMobileParty);
		num *= 2f;
		Vec2 vec = partyToFleeFrom?.Position.ToVec2() ?? (_mobileParty.Position.ToVec2() + averageEnemyVec);
		Vec2 vec2 = vec - _mobileParty.Position.ToVec2();
		float num2 = vec2.Length;
		Vec2 vec3 = -vec2;
		vec3.Normalize();
		vec2 += 3f * averageEnemyVec;
		vec2.Normalize();
		float targetDistance = _mobileParty.LastCalculatedBaseSpeed * 5f;
		GetAccessibleTargetPointInDirection(out fleeTargetPoint, vec3, targetDistance, _mobileParty.Position, 100, doNotEmbarkDisembark: true, randomizeDirection: false);
		bool flag = fleeTargetPoint.NearlyEquals(_mobileParty.Position, num * 0.15f);
		if (!_mobileParty.IsBandit && (partyToFleeFrom == null || _mobileParty.LastCalculatedBaseSpeed > partyToFleeFrom.LastCalculatedBaseSpeed || partyToFleeFrom.MapEvent != null || partyToFleeFrom.SiegeEvent != null))
		{
			bool flag2 = partyToFleeFrom == null;
			bool flag3 = partyToFleeFrom != null && !partyToFleeFrom.IsMoving;
			if (flag2)
			{
				float num3 = _mobileParty.Ships.SumQ((Ship x) => x.HitPoints / x.MaxHitPoints) / (float)_mobileParty.Ships.Count;
				num2 *= num3;
			}
			if (!flag3 && flag)
			{
				float num4 = 0.01f;
				float epsilon = num * 0.75f;
				float num5 = 0.9424779f;
				float num6 = num5 * 0.05f;
				while (num4 <= num5 && fleeTargetPoint.NearlyEquals(_mobileParty.Position, epsilon))
				{
					num4 += num6;
					Vec2 direction = vec3;
					direction.RotateCCW(new CampaignVec2(vec3.LeftVec(), !_mobileParty.IsCurrentlyAtSea).Face.IsValid() ? num4 : (0f - num4));
					bool flag4 = num4 > num5 * 0.66f;
					GetAccessibleTargetPointInDirection(out fleeTargetPoint, direction, num2, _mobileParty.Position, 100, doNotEmbarkDisembark: true, flag4, flag4 ? 0.5f : 0f);
				}
				if (fleeTargetPoint.NearlyEquals(_mobileParty.Position, epsilon))
				{
					fleeTargetPoint = _mobileParty.MoveTargetPoint;
				}
			}
			else if (!_fleeingData.AlreadyReachedTheDestinationWhileFleeing)
			{
				if (_mobileParty.RecalculateLongTermPath())
				{
					float num7 = _mobileParty.NextLongTermPathPoint.Distance(_mobileParty.Position);
					float num8 = _mobileParty.NextLongTermPathPoint.Distance(vec);
					float num9 = ((_mobileParty.Position + vec) * 0.5f).Distance(_mobileParty.NextLongTermPathPoint);
					if (num7 < num8 && num9 > num7)
					{
						bool flag5 = _mobileParty.Position.Distance(_mobileParty.NextLongTermPathPoint) < num;
						if (flag5)
						{
							_mobileParty.RecalculateLongTermPath();
							flag5 = _mobileParty.Path.Size == 1 && _mobileParty.Path.PathPoints[0].NearlyEquals(_mobileParty.Position.ToVec2(), num);
							if (flag5)
							{
								_fleeingData.AlreadyReachedTheDestinationWhileFleeing = true;
							}
						}
						if (!flag5)
						{
							fleeTargetPoint = _mobileParty.NextLongTermPathPoint;
						}
					}
					else if (!flag3 || !(partyToFleeFrom.Position.DistanceSquared(_mobileParty.NextLongTermPathPoint) < 1f))
					{
						Vec2 vec4 = _mobileParty.NextLongTermPathPoint.ToVec2() - vec;
						CampaignVec2 campaignVec = new CampaignVec2(_mobileParty.Position.ToVec2() + vec2.Normalized().RightVec(), !_mobileParty.IsCurrentlyAtSea);
						CampaignVec2 campaignVec2 = new CampaignVec2(_mobileParty.Position.ToVec2() + vec2.Normalized().LeftVec(), !_mobileParty.IsCurrentlyAtSea);
						float num10 = Vec2.Determinant(vec4.Normalized(), vec2.Normalized());
						_fleeingData.CcwFleeDirectionIsBlocked = _fleeingData.CcwFleeDirectionIsBlocked || !campaignVec.Face.IsValid();
						_fleeingData.CwFleeDirectionIsBlocked = _fleeingData.CwFleeDirectionIsBlocked || !campaignVec2.Face.IsValid();
						if (!_fleeingData.CcwFleeDirectionIsBlocked)
						{
							bool flag6 = Campaign.Current.Models.PartyNavigationModel.IsTerrainTypeValidForNavigationType(Campaign.Current.MapSceneWrapper.GetFaceTerrainType(campaignVec.Face), (!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
							_fleeingData.CcwFleeDirectionIsBlocked = !flag6;
						}
						if (!_fleeingData.CwFleeDirectionIsBlocked)
						{
							bool flag7 = Campaign.Current.Models.PartyNavigationModel.IsTerrainTypeValidForNavigationType(Campaign.Current.MapSceneWrapper.GetFaceTerrainType(campaignVec2.Face), (!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
							_fleeingData.CwFleeDirectionIsBlocked = !flag7;
						}
						bool flag8 = _fleeingData.ShouldFleeClockWise || _fleeingData.CcwFleeDirectionIsBlocked || (!_fleeingData.CwFleeDirectionIsBlocked && num10 <= 0f);
						float num11 = (flag2 ? (_mobileParty.LastCalculatedBaseSpeed * 0.75f) : partyToFleeFrom.LastCalculatedBaseSpeed);
						if (flag3)
						{
							num11 *= 0.15f;
							num = 0.5f;
							num2 *= 0.2f;
						}
						float num12 = num2 * num11 / _mobileParty.LastCalculatedBaseSpeed + num * 1.25f;
						float num13 = 2f * (float)Math.Asin(num12 * 0.5f / num2);
						if (!float.IsNaN(num13))
						{
							Vec2 vec5 = vec2.Normalized();
							vec5.RotateCCW(flag8 ? num13 : (0f - num13));
							vec3 = vec5;
							vec3.Normalize();
							Vec2 vec6 = _mobileParty.NextLongTermPathPoint.ToVec2() - _mobileParty.Position.ToVec2();
							Vec2 vec7 = _mobileParty.Position.ToVec2() + vec3 * num2;
							if (TaleWorlds.Library.MathF.Abs(vec6.AngleBetween(vec7 - _mobileParty.Position.ToVec2())) < (flag3 ? 0.8f : 0.2f))
							{
								fleeTargetPoint = _mobileParty.NextLongTermPathPoint;
							}
							else
							{
								GetAccessibleTargetPointInDirection(out fleeTargetPoint, vec3, TaleWorlds.Library.MathF.Clamp(num2 * 3f, num, num * 5f), _mobileParty.Position, 100, doNotEmbarkDisembark: true, randomizeDirection: false);
								if (fleeTargetPoint.NearlyEquals(_mobileParty.Position, num))
								{
									if (flag8)
									{
										_fleeingData.CwFleeDirectionIsBlocked = true;
									}
									else
									{
										_fleeingData.CcwFleeDirectionIsBlocked = true;
									}
									flag8 = !_fleeingData.ShouldFleeClockWise;
								}
							}
							_fleeingData.ShouldFleeClockWise = flag8;
						}
						else if (flag8)
						{
							_fleeingData.CwFleeDirectionIsBlocked = true;
						}
						else
						{
							_fleeingData.CcwFleeDirectionIsBlocked = true;
						}
					}
				}
			}
			else
			{
				_fleeingData.CcwFleeDirectionIsBlocked = true;
				_fleeingData.CwFleeDirectionIsBlocked = true;
			}
		}
		if (flag || (_fleeingData.CcwFleeDirectionIsBlocked && _fleeingData.CwFleeDirectionIsBlocked))
		{
			GetAccessibleTargetPointInDirection(out fleeTargetPoint, vec3, 10f, _mobileParty.Position, 100, doNotEmbarkDisembark: true, randomizeDirection: true, 0.2f);
			_fleeingData.CcwFleeDirectionIsBlocked = true;
			_fleeingData.CwFleeDirectionIsBlocked = true;
		}
	}

	private void GetDefendSettlementBehavior(Settlement targetSettlement, out AiBehavior shortTermBehavior, out CampaignVec2 shortTermTargetPoint, out MobileParty goAroundPartyTargetParty)
	{
		goAroundPartyTargetParty = targetSettlement.LastAttackerParty;
		if (targetSettlement.SiegeEvent != null)
		{
			if (_mobileParty.CurrentSettlement == targetSettlement)
			{
				shortTermBehavior = AiBehavior.GoToSettlement;
				shortTermTargetPoint = _mobileParty.Position;
				return;
			}
			shortTermBehavior = AiBehavior.GoToPoint;
			shortTermTargetPoint = targetSettlement.LastAttackerParty.Position;
			if (targetSettlement.HasPort && !targetSettlement.SiegeEvent.IsBlockadeActive && _mobileParty.HasNavalNavigationCapability)
			{
				if (!_mobileParty.IsTargetingPort)
				{
					_mobileParty.Ai.RethinkAtNextHourlyTick = true;
				}
				shortTermBehavior = AiBehavior.GoToSettlement;
				shortTermTargetPoint = targetSettlement.PortPosition;
			}
			else if (targetSettlement.HasPort && targetSettlement.SiegeEvent.IsBlockadeActive && targetSettlement.SiegeEvent.BesiegerCamp.LeaderParty.MapEvent != null && (targetSettlement.SiegeEvent.BesiegerCamp.LeaderParty.MapEvent.IsBlockade || targetSettlement.SiegeEvent.BesiegerCamp.LeaderParty.MapEvent.IsBlockadeSallyOut))
			{
				if (_mobileParty.HasNavalNavigationCapability)
				{
					shortTermBehavior = AiBehavior.GoToSettlement;
					shortTermTargetPoint = targetSettlement.PortPosition;
				}
				else
				{
					shortTermBehavior = AiBehavior.Hold;
					shortTermTargetPoint = _mobileParty.Position;
				}
			}
			else
			{
				if (!GetNearbyPartyDataWhileDefendingSettlement(targetSettlement, out var shouldConsiderJoiningNearbyAllyParties, out var shouldJoinLandSide, out var shouldEngage, out var _, out var _))
				{
					return;
				}
				bool flag = _mobileParty.ShortTermTargetParty != null && _mobileParty.ShortTermTargetParty.IsActive && !_mobileParty.ShortTermTargetParty.MapFaction.IsAtWarWith(_mobileParty.MapFaction) && _mobileParty.ShortTermTargetParty.MapEvent == null;
				if (!shouldEngage && flag && !shouldConsiderJoiningNearbyAllyParties)
				{
					shortTermBehavior = AiBehavior.GoToPoint;
					goAroundPartyTargetParty = _mobileParty.ShortTermTargetParty;
					GetDefendingPosition(_mobileParty.ShortTermTargetParty.Position, MobileParty.NavigationType.All, 1.5f, out shortTermTargetPoint);
					return;
				}
				if (shouldEngage)
				{
					if (shouldJoinLandSide)
					{
						shortTermBehavior = AiBehavior.EngageParty;
						goAroundPartyTargetParty = targetSettlement.SiegeEvent.BesiegerCamp.LeaderParty;
					}
					else
					{
						shortTermBehavior = AiBehavior.GoToSettlement;
						shortTermTargetPoint = targetSettlement.PortPosition;
					}
					return;
				}
				if (shouldConsiderJoiningNearbyAllyParties)
				{
					shortTermBehavior = AiBehavior.GoToPoint;
					CampaignVec2 targetPosition = (shouldJoinLandSide ? targetSettlement.GatePosition : targetSettlement.PortPosition);
					GetDefendingPosition(targetPosition, MobileParty.NavigationType.All, Campaign.Current.Models.MobilePartyAIModel.SettlementDefendingWaitingPositionRadius, out shortTermTargetPoint);
					return;
				}
				float settlementDefendingWaitingPositionRadius = Campaign.Current.Models.MobilePartyAIModel.SettlementDefendingWaitingPositionRadius;
				if (_mobileParty.IsCurrentlyAtSea && targetSettlement.HasPort && targetSettlement.Party.MapEventSide == null)
				{
					if (!GetDefendingPosition(targetSettlement.PortPosition, MobileParty.NavigationType.Naval, settlementDefendingWaitingPositionRadius, out shortTermTargetPoint))
					{
						GetDefendingPosition(targetSettlement.PortPosition, MobileParty.NavigationType.Naval, settlementDefendingWaitingPositionRadius * 5f, out shortTermTargetPoint);
					}
				}
				else if (!GetDefendingPosition(goAroundPartyTargetParty.Position, (!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.All, settlementDefendingWaitingPositionRadius, out shortTermTargetPoint))
				{
					GetDefendingPosition(goAroundPartyTargetParty.Position, MobileParty.NavigationType.All, settlementDefendingWaitingPositionRadius, out shortTermTargetPoint);
				}
			}
			return;
		}
		GetNearbyPartyDataWhileDefendingSettlement(targetSettlement, out var _, out var shouldJoinLandSide2, out var shouldEngage2, out var _, out var _);
		if (shouldEngage2)
		{
			if (shouldJoinLandSide2)
			{
				shortTermBehavior = AiBehavior.EngageParty;
				goAroundPartyTargetParty = targetSettlement.LastAttackerParty;
				shortTermTargetPoint = targetSettlement.LastAttackerParty.Position;
				if (targetSettlement.LastAttackerParty.IsCurrentlyAtSea && !_mobileParty.HasNavalNavigationCapability)
				{
					shortTermTargetPoint = targetSettlement.GatePosition;
				}
			}
			else
			{
				shortTermBehavior = AiBehavior.GoToSettlement;
				shortTermTargetPoint = targetSettlement.PortPosition;
			}
		}
		else if (_mobileParty.IsCurrentlyAtSea == goAroundPartyTargetParty.IsCurrentlyAtSea)
		{
			GetGoAroundPartyBehavior(goAroundPartyTargetParty, out shortTermBehavior, out shortTermTargetPoint);
		}
		else
		{
			shortTermBehavior = AiBehavior.GoToSettlement;
			shortTermTargetPoint = ((_mobileParty.IsCurrentlyAtSea && targetSettlement.HasPort) ? targetSettlement.PortPosition : targetSettlement.GatePosition);
		}
	}

	public bool GetNearbyPartyDataWhileDefendingSettlement(Settlement targetSettlement, out bool shouldConsiderJoiningNearbyAllyParties, out bool shouldJoinLandSide, out bool shouldEngage, out MobileParty mostPowerfulLandAlly, out MobileParty mostPowerfulNavalAlly)
	{
		shouldEngage = false;
		shouldConsiderJoiningNearbyAllyParties = false;
		shouldJoinLandSide = false;
		mostPowerfulLandAlly = null;
		mostPowerfulNavalAlly = null;
		CampaignVec2 v = ((targetSettlement.SiegeEvent != null) ? targetSettlement.SiegeEvent.BesiegerCamp.LeaderParty.Position : targetSettlement.GatePosition);
		bool flag = _mobileParty.Position.Distance(v) < Campaign.Current.Models.MobilePartyAIModel.SettlementDefendingNearbyPartyCheckRadius;
		if (flag)
		{
			float num = 0f;
			float num2 = 0f;
			if (targetSettlement.IsFortification)
			{
				if (targetSettlement.SiegeEvent != null)
				{
					foreach (PartyBase item in targetSettlement.SiegeEvent.BesiegerCamp.GetInvolvedPartiesForEventType())
					{
						num += item.GetCustomStrength(BattleSideEnum.Defender, MapEvent.PowerCalculationContext.PlainBattle);
						num2 += item.GetCustomStrength(BattleSideEnum.Defender, MapEvent.PowerCalculationContext.SeaBattle);
					}
				}
				else
				{
					num = ((targetSettlement.LastAttackerParty.Army != null && targetSettlement.LastAttackerParty.Army.LeaderParty == targetSettlement.LastAttackerParty) ? targetSettlement.LastAttackerParty.Army.EstimatedStrength : targetSettlement.LastAttackerParty.Party.EstimatedStrength);
				}
			}
			else if (targetSettlement.Party.MapEventSide != null)
			{
				MobileParty mobileParty = targetSettlement.Party.MapEventSide.OtherSide.LeaderParty.MobileParty;
				num = ((mobileParty.Army != null && mobileParty.Army.LeaderParty == mobileParty) ? mobileParty.Army.EstimatedStrength : mobileParty.Party.EstimatedStrength);
			}
			LocatableSearchData<MobileParty> data = MobileParty.StartFindingLocatablesAroundPosition(v.ToVec2(), Campaign.Current.Models.MobilePartyAIModel.SettlementDefendingNearbyPartyCheckRadius);
			MobileParty mobileParty2 = MobileParty.FindNextLocatable(ref data);
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 0f;
			float num7 = 0f;
			float num8 = 0f;
			while (mobileParty2 != null)
			{
				if (mobileParty2.AttachedTo == null && ((mobileParty2.DefaultBehavior == AiBehavior.DefendSettlement && mobileParty2.TargetSettlement == targetSettlement) || (mobileParty2.ShortTermBehavior == AiBehavior.EngageParty && mobileParty2.ShortTermTargetParty == targetSettlement.LastAttackerParty)))
				{
					float num9 = mobileParty2.Army?.GetCustomStrength(BattleSideEnum.Attacker, MapEvent.PowerCalculationContext.PlainBattle) ?? mobileParty2.Party.GetCustomStrength(BattleSideEnum.Attacker, MapEvent.PowerCalculationContext.PlainBattle);
					if (targetSettlement.HasPort)
					{
						float num10 = mobileParty2.Army?.GetCustomStrength(BattleSideEnum.Attacker, MapEvent.PowerCalculationContext.SeaBattle) ?? mobileParty2.Party.GetCustomStrength(BattleSideEnum.Attacker, MapEvent.PowerCalculationContext.SeaBattle);
						num4 += num10;
						if (mostPowerfulNavalAlly == null || num8 < num10)
						{
							mostPowerfulNavalAlly = mobileParty2;
							num8 = num10;
						}
					}
					num3 += num9;
					if (mostPowerfulLandAlly == null || num7 < num9)
					{
						mostPowerfulLandAlly = mobileParty2;
						num7 = num9;
					}
					if (mobileParty2.IsCurrentlyAtSea)
					{
						num6 += mobileParty2.Army?.EstimatedStrength ?? mobileParty2.Party.EstimatedStrength;
					}
					else
					{
						num5 += mobileParty2.Army?.EstimatedStrength ?? mobileParty2.Party.EstimatedStrength;
					}
				}
				mobileParty2 = MobileParty.FindNextLocatable(ref data);
			}
			shouldConsiderJoiningNearbyAllyParties = num3 > num || num4 > num2;
			if (shouldConsiderJoiningNearbyAllyParties)
			{
				float num11 = num3 - num;
				float num12 = num4 - num2;
				bool flag2 = targetSettlement.Party.MapEventSide != null && !targetSettlement.Party.MapEvent.IsNavalMapEvent;
				bool flag3 = targetSettlement.Party.MapEventSide != null && targetSettlement.Party.MapEvent.IsNavalMapEvent;
				if (num11 > 0f && num11 > num12)
				{
					shouldJoinLandSide = !flag3;
				}
				if (num12 > 0f && num12 > num11)
				{
					shouldJoinLandSide = flag2;
				}
				if (shouldJoinLandSide && num5 > num * 1.2f)
				{
					shouldEngage = true;
				}
				if (!shouldJoinLandSide && num6 > num2 * 1.4f)
				{
					shouldEngage = true;
				}
				if ((targetSettlement.SiegeEvent == null || !targetSettlement.SiegeEvent.BesiegerCamp.IsBesiegerSideParty(MobileParty.MainParty)) && ((((mostPowerfulLandAlly != null) & shouldJoinLandSide) && mostPowerfulLandAlly != _mobileParty && (mostPowerfulLandAlly.MapEvent != null || (mostPowerfulLandAlly.ShortTermBehavior == AiBehavior.EngageParty && mostPowerfulLandAlly.ShortTermTargetParty == targetSettlement.SiegeEvent?.BesiegerCamp.LeaderParty))) || (mostPowerfulNavalAlly != null && !shouldJoinLandSide && mostPowerfulNavalAlly != _mobileParty && (mostPowerfulNavalAlly.MapEvent != null || (mostPowerfulNavalAlly.ShortTermBehavior == AiBehavior.GoToSettlement && mostPowerfulNavalAlly.TargetPosition == targetSettlement.PortPosition)))))
				{
					shouldEngage = true;
				}
				if (!_mobileParty.HasNavalNavigationCapability && !shouldJoinLandSide)
				{
					shouldConsiderJoiningNearbyAllyParties = false;
				}
			}
		}
		return flag;
	}

	private void GetGoAroundPartyBehavior(MobileParty targetParty, out AiBehavior goAroundPartyBehavior, out CampaignVec2 goAroundPartyTargetPoint)
	{
		CampaignVec2 campaignVec = (goAroundPartyTargetPoint = targetParty.Position);
		float defendRadius = Campaign.Current.Models.EncounterModel.GetEncounterJoiningRadius * 1.15f;
		MobileParty.NavigationType navigationType = (campaignVec.IsOnLand ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
		if (GetDefendingPosition(targetParty.Position, navigationType, defendRadius, out var possibleTargetPoint))
		{
			if (MBRandom.RandomFloat < 0.2f * _mobileParty.AiBehaviorTarget.DistanceSquared(possibleTargetPoint) || targetParty._lastCalculatedSpeed > _mobileParty._lastCalculatedSpeed)
			{
				goAroundPartyTargetPoint = possibleTargetPoint;
			}
			else
			{
				goAroundPartyTargetPoint = _mobileParty.AiBehaviorTarget;
			}
			goAroundPartyBehavior = AiBehavior.GoToPoint;
		}
		else
		{
			goAroundPartyBehavior = AiBehavior.EngageParty;
			goAroundPartyTargetPoint = targetParty.Position;
		}
	}

	private bool GetDefendingPosition(CampaignVec2 targetPosition, MobileParty.NavigationType navigationType, float defendRadius, out CampaignVec2 possibleTargetPoint)
	{
		Vec2 vec = _mobileParty.Position.ToVec2() - targetPosition.ToVec2();
		float length = vec.Length;
		vec.Normalize();
		bool flag = false;
		possibleTargetPoint = targetPosition;
		int num = 5;
		while (num >= 0 && !flag)
		{
			int num2 = _mobileParty.RandomInt(-4, 5);
			for (int i = 1; i <= 2; i++)
			{
				if (flag)
				{
					break;
				}
				for (int j = num2; j < num2 + 9; j++)
				{
					Vec2 vec2 = vec;
					vec2.RotateCCW((float)j / 9f * (System.MathF.PI / 2f) * (float)i * 0.5f * (TaleWorlds.Library.MathF.Min(TaleWorlds.Library.MathF.Max(0f, length - defendRadius * defendRadius * 0.5f), 3f * defendRadius) / (3f * defendRadius)));
					CampaignVec2 toPoint = targetPosition + vec2 * defendRadius * defendRadius * 0.5f * ((float)num / 5f);
					if (toPoint.IsValid() && NavigationHelper.IsPositionValidForNavigationType(toPoint, navigationType) && (navigationType == MobileParty.NavigationType.All || Campaign.Current.Models.MapDistanceModel.PathExistBetweenPoints(_mobileParty.Position, in toPoint, navigationType)))
					{
						flag = true;
						possibleTargetPoint = toPoint;
						break;
					}
				}
			}
			num--;
		}
		return flag;
	}

	private void GetNavalPatrolBehavior(out AiBehavior patrolBehavior, out CampaignVec2 patrolTargetPoint, CampaignVec2 patrollingCenterPoint, bool forceUpdate)
	{
		patrolBehavior = AiBehavior.GoToPoint;
		patrolTargetPoint = (forceUpdate ? patrollingCenterPoint : _mobileParty.MoveTargetPoint);
		bool flag = forceUpdate || MBRandom.RandomFloat < 0.1f * Campaign.Current.Models.MobilePartyAIModel.AiCheckInterval;
		if (!flag && _mobileParty.IsBandit)
		{
			CampaignVec2 position = _mobileParty.Position + _mobileParty.Bearing;
			if (!position.IsValid())
			{
				position = _mobileParty.Position;
			}
			flag = Campaign.Current.Models.BanditDensityModel.IsPositionInsideNavalSafeZone(position);
		}
		if (!flag)
		{
			return;
		}
		float patrolRadius = Campaign.Current.Models.MobilePartyAIModel.GetPatrolRadius(_mobileParty, patrolTargetPoint);
		if (_mobileParty.IsLordParty)
		{
			if (!_mobileParty.IsCurrentlyAtSea)
			{
				patrolBehavior = AiBehavior.GoToPoint;
				patrolTargetPoint = _mobileParty.TargetSettlement.PortPosition;
				return;
			}
			int num = 0;
			CampaignVec2 zero = CampaignVec2.Zero;
			TerrainType terrainType = TerrainType.Plain;
			do
			{
				zero = NavigationHelper.FindPointAroundPosition(patrollingCenterPoint, _mobileParty.DesiredAiNavigationType, patrolRadius, patrolRadius * 0.5f);
				terrainType = Campaign.Current.MapSceneWrapper.GetFaceTerrainType(zero.Face);
				num++;
			}
			while (num < 100 && terrainType != TerrainType.CoastalSea && terrainType != TerrainType.NonNavigableRiver && terrainType != TerrainType.River && terrainType != TerrainType.UnderBridge);
			patrolBehavior = AiBehavior.GoToPoint;
			patrolTargetPoint = zero;
		}
		else
		{
			CampaignVec2 campaignVec = NavigationHelper.FindPointAroundPosition(patrollingCenterPoint, MobileParty.NavigationType.Naval, patrolRadius, 0f, requirePath: true, useUniformDistribution: true);
			int num2 = 0;
			do
			{
				campaignVec = NavigationHelper.FindPointAroundPosition(patrollingCenterPoint, MobileParty.NavigationType.Naval, patrolRadius);
				num2++;
			}
			while (num2 < 100 && Campaign.Current.Models.BanditDensityModel.IsPositionInsideNavalSafeZone(campaignVec));
			patrolBehavior = AiBehavior.GoToPoint;
			patrolTargetPoint = campaignVec;
		}
	}

	private void GetLandPatrolBehavior(out AiBehavior patrolBehavior, out CampaignVec2 patrolTargetPoint, CampaignVec2 patrollingCenterPoint, bool forceUpdate)
	{
		float num = _mobileParty.AiBehaviorTarget.DistanceSquared(_mobileParty.Position);
		patrolBehavior = AiBehavior.GoToPoint;
		patrolTargetPoint = _mobileParty.AiBehaviorTarget;
		if (!(num < 1f || forceUpdate) && patrolTargetPoint.IsNonZero())
		{
			return;
		}
		if (MBRandom.RandomFloat < 0.5f * Campaign.Current.Models.MobilePartyAIModel.AiCheckInterval || forceUpdate)
		{
			Vec2 vec = patrollingCenterPoint.ToVec2() - _mobileParty.Position.ToVec2();
			float num2 = vec.Normalize();
			float patrolRadius = Campaign.Current.Models.MobilePartyAIModel.GetPatrolRadius(_mobileParty, patrolTargetPoint);
			float num3 = TaleWorlds.Library.MathF.Max(num2 * 0.25f, patrolRadius);
			if (_mobileParty.IsCurrentlyAtSea == patrollingCenterPoint.IsOnLand || num2 > num3 * (3.2f / (_mobileParty.IsCurrentlyUsedByAQuest ? 1.5f : 1f)))
			{
				patrolBehavior = AiBehavior.GoToPoint;
				CampaignVec2 campaignVec = ((_mobileParty.TargetSettlement == null) ? patrollingCenterPoint : (_mobileParty.IsTargetingPort ? _mobileParty.TargetSettlement.PortPosition : _mobileParty.TargetSettlement.GatePosition));
				patrolTargetPoint = campaignVec;
				return;
			}
			float num4 = ((_mobileParty.TargetSettlement != null && _mobileParty.TargetSettlement.NearbyLandThreatIntensity > 1f) ? (TaleWorlds.Library.MathF.Sqrt(_mobileParty.TargetSettlement.NearbyLandThreatIntensity) - 1f) : 0f);
			float num5 = TaleWorlds.Library.MathF.Max(0f, TaleWorlds.Library.MathF.Min(0.9f, num2 / (num3 / (((_mobileParty.TargetSettlement != null && _mobileParty.TargetSettlement.MapFaction == _mobileParty.MapFaction) ? num4 : 0f) + 1f)) - 0.4f));
			Vec2 direction = (1f - num5) * _mobileParty.Bearing + num5 * vec;
			direction.RotateCCW((-0.3f + MBRandom.RandomFloat) * 0.15f);
			direction.Normalize();
			float num6 = 0.5f + 0.5f * MBRandom.RandomFloat;
			float rotationChangeLimitAddition = ((num2 > patrolRadius * 4f) ? 0.2f : ((num2 > patrolRadius * 2f) ? 0.4f : ((num2 > patrolRadius) ? 0.6f : 1f)));
			GetAccessibleTargetPointInDirection(out patrolTargetPoint, direction, num3 * num6, patrollingCenterPoint, 20, doNotEmbarkDisembark: true, randomizeDirection: true, rotationChangeLimitAddition);
		}
		else
		{
			patrolTargetPoint = patrollingCenterPoint;
		}
	}

	private void SetAiBehavior(AiBehavior newAiBehavior, IInteractablePoint interactablePoint, CampaignVec2 bestTargetPoint)
	{
		_mobileParty.SetShortTermBehavior(newAiBehavior, interactablePoint);
		BehaviorTarget = bestTargetPoint;
		UpdateBehavior();
	}

	private void UpdateBehavior()
	{
		if (_mobileParty.ShortTermBehavior == AiBehavior.GoToPoint || _mobileParty.ShortTermBehavior == AiBehavior.FleeToPoint || _mobileParty.ShortTermBehavior == AiBehavior.FleeToGate || _mobileParty.ShortTermBehavior == AiBehavior.FleeToParty || _mobileParty.ShortTermBehavior == AiBehavior.MoveToNearestLandOrPort || ((_mobileParty.ShortTermBehavior == AiBehavior.GoToSettlement || _mobileParty.ShortTermBehavior == AiBehavior.RaidSettlement || _mobileParty.ShortTermBehavior == AiBehavior.AssaultSettlement || _mobileParty.ShortTermBehavior == AiBehavior.BesiegeSettlement) && AiBehaviorPartyBase != null && AiBehaviorPartyBase.IsValid))
		{
			_mobileParty.SetNavigationModePoint(BehaviorTarget);
		}
		else
		{
			switch (_mobileParty.ShortTermBehavior)
			{
			case AiBehavior.EngageParty:
				_mobileParty.SetNavigationModeParty(AiBehaviorPartyBase.MobileParty);
				break;
			case AiBehavior.Hold:
				_mobileParty.SetNavigationModeHold();
				break;
			default:
				Debug.FailedAssert("false", "C:\\BuildAgent\\work\\mb3\\Source\\Bannerlord\\TaleWorlds.CampaignSystem\\Party\\MobilePartyAi.cs", "UpdateBehavior", 1701);
				break;
			case AiBehavior.FleeToPoint:
			case AiBehavior.FleeToGate:
			case AiBehavior.FleeToParty:
			case AiBehavior.DefendSettlement:
				break;
			}
		}
		if (!_mobileParty.IsMainParty && _mobileParty.BesiegedSettlement != null && _mobileParty.DefaultBehavior != AiBehavior.BesiegeSettlement && _mobileParty.DefaultBehavior != AiBehavior.EscortParty && _mobileParty.DefaultBehavior != AiBehavior.AssaultSettlement)
		{
			_mobileParty.BesiegerCamp = null;
		}
	}

	private MobileParty GetNearbyPartyToFlee(MobileParty partyToFleeFrom, Vec2 fleeDirection)
	{
		(MobileParty, float) tuple = (null, 0f);
		float fleeToNearbyPartyRadius = Campaign.Current.Models.MobilePartyAIModel.FleeToNearbyPartyRadius;
		MobileParty.NavigationType navigationType = ((!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
		float estimatedStrength = _mobileParty.Party.EstimatedStrength;
		float estimatedStrength2 = partyToFleeFrom.Party.EstimatedStrength;
		LocatableSearchData<MobileParty> data = MobileParty.StartFindingLocatablesAroundPosition(_mobileParty.Position.ToVec2(), fleeToNearbyPartyRadius);
		MobileParty mobileParty = MobileParty.FindNextLocatable(ref data);
		while (mobileParty != null)
		{
			if (!mobileParty.IsMilitia && !mobileParty.IsGarrison && !mobileParty.IsCaravan && mobileParty != _mobileParty && (mobileParty.MapFaction == _mobileParty.MapFaction || (mobileParty.IsBandit && _mobileParty.IsBandit)) && DistanceHelper.FindClosestDistanceFromMobilePartyToMobileParty(_mobileParty, mobileParty, navigationType) < Campaign.MapDiagonal)
			{
				if (mobileParty.AttachedTo != null || mobileParty.CurrentSettlement != null || mobileParty.MapEvent != null)
				{
					mobileParty = MobileParty.FindNextLocatable(ref data);
					continue;
				}
				if (!NavigationHelper.IsPositionValidForNavigationType(mobileParty.Position, navigationType))
				{
					mobileParty = MobileParty.FindNextLocatable(ref data);
					continue;
				}
				float num = ((mobileParty.Army != null && mobileParty.Army.DoesLeaderPartyAndAttachedPartiesContain(_mobileParty)) ? mobileParty.Army.EstimatedStrength : mobileParty.Party.EstimatedStrength);
				if (num > estimatedStrength && (_mobileParty.IsBandit || num + estimatedStrength > estimatedStrength2 * 0.5f))
				{
					float num2 = DistanceHelper.FindClosestDistanceFromMobilePartyToMobileParty(_mobileParty, mobileParty, navigationType);
					if (num2 > Campaign.MapDiagonal)
					{
						mobileParty = MobileParty.FindNextLocatable(ref data);
						continue;
					}
					CampaignVec2 campaignVec = mobileParty.Position - _mobileParty.Position;
					if (num2 < 1f && mobileParty._lastCalculatedSpeed < _mobileParty._lastCalculatedSpeed)
					{
						mobileParty = MobileParty.FindNextLocatable(ref data);
						continue;
					}
					float length = (partyToFleeFrom.Position.ToVec2() - mobileParty.Position.ToVec2()).Length;
					campaignVec.Normalize();
					if (campaignVec.DistanceSquared(fleeDirection) < 0.3f + 0.1f * (fleeToNearbyPartyRadius - Math.Min(fleeToNearbyPartyRadius, num2)) && num2 < length * 0.86f)
					{
						float num3 = num2 * 0.66f + num * 0.34f;
						if (tuple.Item2 < num3)
						{
							tuple.Item1 = mobileParty;
							tuple.Item2 = num3;
						}
					}
				}
			}
			mobileParty = MobileParty.FindNextLocatable(ref data);
		}
		return tuple.Item1;
	}

	private void GetBehaviorForNearbySettlementToFlee(MobileParty partyToFleeFrom, Vec2 fleeDirection, out Settlement fleeSettlement, out CampaignVec2 targetPoint, out AiBehavior aiBehavior)
	{
		float num = Campaign.Current.Models.EncounterModel.NeededMaximumDistanceForEncounteringTown * 2f;
		fleeSettlement = null;
		targetPoint = _mobileParty.Position;
		aiBehavior = AiBehavior.FleeToPoint;
		MobileParty.NavigationType navigationType = ((!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
		LocatableSearchData<Settlement> data = Campaign.Current.SettlementLocator.StartFindingLocatablesAroundPosition(_mobileParty.Position.ToVec2(), Campaign.Current.Models.MobilePartyAIModel.FleeToNearbySettlementRadius);
		for (Settlement settlement = Campaign.Current.SettlementLocator.FindNextLocatable(ref data); settlement != null; settlement = Campaign.Current.SettlementLocator.FindNextLocatable(ref data))
		{
			if ((settlement.IsFortification || (settlement.IsVillage && _mobileParty.IsVillager && _mobileParty.HomeSettlement == settlement)) && !settlement.MapFaction.IsAtWarWith(_mobileParty.MapFaction) && (!settlement.IsUnderSiege || (settlement.HasPort && !settlement.SiegeEvent.IsBlockadeActive && _mobileParty.IsCurrentlyAtSea)) && (navigationType != MobileParty.NavigationType.Naval || settlement.HasPort) && DistanceHelper.FindClosestDistanceFromMobilePartyToSettlement(_mobileParty, settlement, navigationType) < Campaign.MapDiagonal)
			{
				CampaignVec2 v = ((_mobileParty.IsCurrentlyAtSea && settlement.HasPort) ? settlement.PortPosition : settlement.GatePosition);
				Vec2 vec = v.ToVec2() - _mobileParty.Position.ToVec2();
				float length = vec.Length;
				vec.Normalize();
				float f = vec.AngleBetween(fleeDirection.Normalized());
				bool flag = partyToFleeFrom.Position.DistanceSquared(v) / partyToFleeFrom._lastCalculatedSpeed > _mobileParty.Position.DistanceSquared(v) / _mobileParty._lastCalculatedSpeed;
				if (TaleWorlds.Library.MathF.Abs(f) < 0.1f || length < num || (length < Campaign.Current.Models.EncounterModel.GetEncounterJoiningRadius * 2f && flag))
				{
					if (length > num)
					{
						aiBehavior = AiBehavior.FleeToGate;
						fleeSettlement = settlement;
					}
					else
					{
						aiBehavior = AiBehavior.GoToSettlement;
						fleeSettlement = settlement;
					}
				}
			}
		}
		if (fleeSettlement != null)
		{
			targetPoint = (_mobileParty.IsCurrentlyAtSea ? fleeSettlement.PortPosition : fleeSettlement.GatePosition);
		}
	}

	private bool GetAccessibleTargetPointInDirection(out CampaignVec2 targetPoint, Vec2 direction, float targetDistance, CampaignVec2 alternativePosition, int neededTriesForAlternative, bool doNotEmbarkDisembark, bool randomizeDirection, float rotationChangeLimitAddition = 0f)
	{
		targetPoint = _mobileParty.Position;
		float num = 2f * rotationChangeLimitAddition;
		float num2 = 1f;
		bool flag = false;
		int num3 = 0;
		while (!flag)
		{
			Vec2 vec = direction;
			if (randomizeDirection)
			{
				vec.RotateCCW((-0.5f + MBRandom.RandomFloat) * num);
				num += rotationChangeLimitAddition;
			}
			targetPoint = _mobileParty.Position + vec * targetDistance * num2;
			num3++;
			num2 *= 0.97f;
			PathFaceRecord face = targetPoint.Face;
			MobileParty.NavigationType navigationType = ((!_mobileParty.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
			MobileParty.NavigationType navigationType2 = (doNotEmbarkDisembark ? navigationType : _mobileParty.NavigationCapability);
			if (face.IsValid() && NavigationHelper.IsPositionValidForNavigationType(face, navigationType2) && targetPoint.Distance(_mobileParty.Position) < targetDistance && (targetPoint.X > Campaign.Current.MinSettlementX - 50f || targetPoint.X > _mobileParty.Position.X) && (targetPoint.Y > Campaign.Current.MinSettlementY - 50f || targetPoint.Y > _mobileParty.Position.Y) && (targetPoint.X < Campaign.Current.MaxSettlementX + 50f || targetPoint.X < _mobileParty.Position.X) && (targetPoint.Y < Campaign.Current.MaxSettlementY + 50f || targetPoint.Y < _mobileParty.Position.Y) && Campaign.Current.Models.MapDistanceModel.PathExistBetweenPoints(in targetPoint, _mobileParty.Position, navigationType))
			{
				flag = num3 >= neededTriesForAlternative || CheckIfThereIsAnyHugeObstacleBetweenPartyAndTarget(_mobileParty, targetPoint.ToVec2());
			}
			if (num3 >= neededTriesForAlternative)
			{
				flag = true;
				targetPoint = alternativePosition;
			}
		}
		return flag;
	}

	public void DisableForHours(int hours)
	{
		_isDisabled = true;
		_enableAgainAtHour = CampaignTime.Now + CampaignTime.Hours(hours);
	}

	public void DisableAi()
	{
		_isDisabled = true;
		_enableAgainAtHour = CampaignTime.Never;
	}

	public void EnableAi()
	{
		_isDisabled = false;
		_enableAgainAtHour = CampaignTime.Now;
	}

	public bool EnableAgainAtHourIsPast()
	{
		return _enableAgainAtHour.IsPast;
	}

	public void SetDoNotAttackMainParty(int hours)
	{
		if (DoNotAttackMainPartyUntil.RemainingHoursFromNow < (float)hours)
		{
			DoNotAttackMainPartyUntil = CampaignTime.HoursFromNow(hours);
		}
	}

	internal void ForceDefaultBehaviorUpdate()
	{
		DefaultBehaviorNeedsUpdate = true;
	}

	public void SetInitiative(float attackInitiative, float avoidInitiative, float hoursUntilReset)
	{
		if (_mobileParty != MobileParty.MainParty)
		{
			_attackInitiative = attackInitiative;
			_avoidInitiative = avoidInitiative;
			_initiativeRestoreTime = CampaignTime.HoursFromNow(hoursUntilReset);
		}
	}

	public void SetDoNotMakeNewDecisions(bool doNotMakeNewDecisions)
	{
		DoNotMakeNewDecisions = doNotMakeNewDecisions;
	}

	internal void InitializeForOldSaves(float attackInitiative, float avoidInitiative, CampaignTime initiativeRestoreTime, int numberOfRecentFleeingFromAParty, AiBehavior aiBehavior, Vec2 oldAiBehaviorTarget, bool oldAiPathMode, bool oldAiPathNeeded, MoveModeType oldPartyMoveMode, MobileParty oldMoveTargetParty, Vec2 oldNextTargetPosition, Vec2 oldMoveTargetPoint, Vec2 oldAiPathLastPosition, Vec2 oldFormationPosition, IInteractablePoint oldAiBehaviorMapEntity, CampaignTime oldDoNotAttackMainPartyUntil)
	{
		_attackInitiative = attackInitiative;
		_avoidInitiative = avoidInitiative;
		_initiativeRestoreTime = initiativeRestoreTime;
		BehaviorTarget = new CampaignVec2(oldAiBehaviorTarget, isOnLand: true);
		AiBehaviorInteractable = oldAiBehaviorMapEntity;
		DoNotAttackMainPartyUntil = oldDoNotAttackMainPartyUntil;
	}

	internal static bool CheckIfThereIsAnyHugeObstacleBetweenPartyAndTarget(MobileParty party, Vec2 newTargetPosition)
	{
		MobileParty.NavigationType navigationType = ((!party.IsCurrentlyAtSea) ? MobileParty.NavigationType.Default : MobileParty.NavigationType.Naval);
		Vec2 vec = party.Position.ToVec2();
		Vec2 pos = new Vec2((newTargetPosition.x + vec.x * 3f) * 0.25f, (newTargetPosition.y + vec.y * 3f) * 0.25f);
		CampaignVec2 fromPoint = new CampaignVec2(pos, !party.IsCurrentlyAtSea);
		if (fromPoint.IsValid())
		{
			Vec2 pos2 = new Vec2((newTargetPosition.x + vec.x) * 0.5f, (newTargetPosition.y + vec.y) * 0.5f);
			CampaignVec2 fromPoint2 = new CampaignVec2(pos2, !party.IsCurrentlyAtSea);
			if (fromPoint2.IsValid())
			{
				Vec2 pos3 = new Vec2((newTargetPosition.x * 3f + vec.x) * 0.25f, (newTargetPosition.y * 3f + vec.y) * 0.25f);
				CampaignVec2 fromPoint3 = new CampaignVec2(pos3, !party.IsCurrentlyAtSea);
				if (fromPoint3.IsValid())
				{
					MapDistanceModel mapDistanceModel = Campaign.Current.Models.MapDistanceModel;
					if (mapDistanceModel.PathExistBetweenPoints(in fromPoint, party.Position, navigationType) && mapDistanceModel.PathExistBetweenPoints(in fromPoint2, party.Position, navigationType))
					{
						return mapDistanceModel.PathExistBetweenPoints(in fromPoint3, party.Position, navigationType);
					}
					return false;
				}
			}
		}
		return false;
	}
}
