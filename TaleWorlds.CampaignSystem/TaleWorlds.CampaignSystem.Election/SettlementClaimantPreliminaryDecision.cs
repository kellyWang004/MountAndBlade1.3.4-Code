using System.Collections.Generic;
using System.Linq;
using Helpers;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Core.ImageIdentifiers;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.CampaignSystem.Election;

public class SettlementClaimantPreliminaryDecision : KingdomDecision
{
	public class SettlementClaimantPreliminaryOutcome : DecisionOutcome
	{
		[SaveableField(400)]
		public bool ShouldSettlementOwnerChange;

		internal static void AutoGeneratedStaticCollectObjectsSettlementClaimantPreliminaryOutcome(object o, List<object> collectedObjects)
		{
			((SettlementClaimantPreliminaryOutcome)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
		{
			base.AutoGeneratedInstanceCollectObjects(collectedObjects);
		}

		internal static object AutoGeneratedGetMemberValueShouldSettlementOwnerChange(object o)
		{
			return ((SettlementClaimantPreliminaryOutcome)o).ShouldSettlementOwnerChange;
		}

		public override TextObject GetDecisionTitle()
		{
			TextObject textObject = new TextObject("{=kakxnaN5}{?SUPPORT}Yes{?}No{\\?}");
			textObject.SetTextVariable("SUPPORT", ShouldSettlementOwnerChange ? 1 : 0);
			return textObject;
		}

		public override TextObject GetDecisionDescription()
		{
			if (ShouldSettlementOwnerChange)
			{
				return new TextObject("{=1bbsq6uw}We should award this fief to a new clan");
			}
			return new TextObject("{=uBcEUdxu}Ownership of the fief should remain as it is");
		}

		public override string GetDecisionLink()
		{
			return null;
		}

		public override ImageIdentifier GetDecisionImageIdentifier()
		{
			return null;
		}

		public SettlementClaimantPreliminaryOutcome(bool shouldSettlementOwnerChange)
		{
			ShouldSettlementOwnerChange = shouldSettlementOwnerChange;
		}
	}

	[SaveableField(400)]
	public readonly Settlement Settlement;

	[SaveableField(401)]
	private Clan _ownerClan;

	internal static void AutoGeneratedStaticCollectObjectsSettlementClaimantPreliminaryDecision(object o, List<object> collectedObjects)
	{
		((SettlementClaimantPreliminaryDecision)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		base.AutoGeneratedInstanceCollectObjects(collectedObjects);
		collectedObjects.Add(Settlement);
		collectedObjects.Add(_ownerClan);
	}

	internal static object AutoGeneratedGetMemberValueSettlement(object o)
	{
		return ((SettlementClaimantPreliminaryDecision)o).Settlement;
	}

	internal static object AutoGeneratedGetMemberValue_ownerClan(object o)
	{
		return ((SettlementClaimantPreliminaryDecision)o)._ownerClan;
	}

	public SettlementClaimantPreliminaryDecision(Clan proposerClan, Settlement settlement)
		: base(proposerClan)
	{
		Settlement = settlement;
		_ownerClan = settlement.OwnerClan;
	}

	public override bool IsAllowed()
	{
		return Campaign.Current.Models.KingdomDecisionPermissionModel.IsAnnexationDecisionAllowed(Settlement);
	}

	public override int GetProposalInfluenceCost()
	{
		return Campaign.Current.Models.DiplomacyModel.GetInfluenceCostOfAnnexation(base.ProposerClan);
	}

	public override TextObject GetGeneralTitle()
	{
		TextObject textObject = new TextObject("{=XFr4IfXf} Change Owner of {SETTLEMENT}");
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		return textObject;
	}

	public override TextObject GetSupportTitle()
	{
		TextObject textObject = new TextObject("{=a48xlNUb}Should the owner of {SETTLEMENT} change?");
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		return textObject;
	}

	public override TextObject GetChooseTitle()
	{
		TextObject textObject = new TextObject("{=a48xlNUb}Should the owner of {SETTLEMENT} change?");
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		return textObject;
	}

	public override TextObject GetSupportDescription()
	{
		TextObject textObject = new TextObject("{=hBJbnoDn}{FACTION_LEADER} will decide if the owner of {SETTLEMENT} will change.");
		textObject.SetTextVariable("FACTION_LEADER", DetermineChooser().Leader.Name);
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		return textObject;
	}

	public override TextObject GetChooseDescription()
	{
		TextObject textObject = new TextObject("{=JHR4ySCf}As {?IS_FEMALE}queen{?}king{\\?} you must decide if the owner of {SETTLEMENT} should change.");
		textObject.SetTextVariable("IS_FEMALE", DetermineChooser().Leader.IsFemale ? 1 : 0);
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		return textObject;
	}

	public override float CalculateMeritOfOutcome(DecisionOutcome candidateOutcome)
	{
		float num = 0f;
		float num2 = 50f;
		List<Clan> list = new List<Clan>();
		if (_ownerClan.Kingdom != null)
		{
			list.AddRange(_ownerClan.Kingdom.Clans.ToList());
		}
		else
		{
			list.Add(_ownerClan);
		}
		foreach (Clan item in list)
		{
			int relation = item.Leader.GetRelation(_ownerClan.Leader);
			bool shouldSettlementOwnerChange = ((SettlementClaimantPreliminaryOutcome)candidateOutcome).ShouldSettlementOwnerChange;
			if ((!shouldSettlementOwnerChange && relation > 0) || (shouldSettlementOwnerChange && relation <= 0))
			{
				num += num2 * (float)MathF.Abs(relation);
			}
		}
		return num;
	}

	public override IEnumerable<DecisionOutcome> DetermineInitialCandidates()
	{
		yield return new SettlementClaimantPreliminaryOutcome(shouldSettlementOwnerChange: true);
		yield return new SettlementClaimantPreliminaryOutcome(shouldSettlementOwnerChange: false);
	}

	public override Clan DetermineChooser()
	{
		return ((Kingdom)Settlement.MapFaction).RulingClan;
	}

	protected override bool ShouldBeCancelledInternal()
	{
		return Settlement.MapFaction != base.Kingdom;
	}

	public float CalculateSupport(Clan clan)
	{
		return DetermineSupport(clan, new SettlementClaimantPreliminaryOutcome(shouldSettlementOwnerChange: true));
	}

	public override float DetermineSupport(Clan clan, DecisionOutcome possibleOutcome)
	{
		bool shouldSettlementOwnerChange = ((SettlementClaimantPreliminaryOutcome)possibleOutcome).ShouldSettlementOwnerChange;
		int num = clan.GetRelationWithClan(_ownerClan);
		if (clan == _ownerClan)
		{
			num = 300;
		}
		float num2 = 20f;
		if (Settlement.OwnerClan == clan)
		{
			num2 *= 20f;
		}
		else
		{
			num2 += (float)num * 0.7f;
			float currentTotalStrength = Settlement.OwnerClan.CurrentTotalStrength;
			num2 += currentTotalStrength * 0.01f;
		}
		float result = 0f;
		if (shouldSettlementOwnerChange)
		{
			result = 0f - num2;
		}
		else if (!shouldSettlementOwnerChange)
		{
			result = num2;
		}
		return result;
	}

	public override void DetermineSponsors(MBReadOnlyList<DecisionOutcome> possibleOutcomes)
	{
		foreach (DecisionOutcome possibleOutcome in possibleOutcomes)
		{
			if (((SettlementClaimantPreliminaryOutcome)possibleOutcome).ShouldSettlementOwnerChange)
			{
				possibleOutcome.SetSponsor(base.ProposerClan);
			}
			else
			{
				AssignDefaultSponsor(possibleOutcome);
			}
		}
	}

	protected override int GetInfluenceCostOfSupportInternal(Supporter.SupportWeights supportWeight)
	{
		if (Settlement.IsTown)
		{
			return supportWeight switch
			{
				Supporter.SupportWeights.FullyPush => 200, 
				Supporter.SupportWeights.StronglyFavor => 60, 
				Supporter.SupportWeights.SlightlyFavor => 20, 
				_ => 0, 
			};
		}
		return supportWeight switch
		{
			Supporter.SupportWeights.FullyPush => 150, 
			Supporter.SupportWeights.StronglyFavor => 50, 
			Supporter.SupportWeights.SlightlyFavor => 15, 
			_ => 0, 
		};
	}

	public override void ApplyChosenOutcome(DecisionOutcome chosenOutcome)
	{
		if (((SettlementClaimantPreliminaryOutcome)chosenOutcome).ShouldSettlementOwnerChange)
		{
			SettlementClaimantDecision settlementClaimantDecision = new SettlementClaimantDecision(base.ProposerClan, Settlement, null, _ownerClan);
			settlementClaimantDecision.IsEnforced = true;
			base.ProposerClan.Kingdom.AddDecision(settlementClaimantDecision, ignoreInfluenceCost: true);
		}
	}

	public override TextObject GetSecondaryEffects()
	{
		return new TextObject("{=CsZfuPOe}Voting against or in favor of the current owner of the settlement will affect your relation with that clan accordingly.");
	}

	public override void ApplySecondaryEffects(MBReadOnlyList<DecisionOutcome> possibleOutcomes, DecisionOutcome chosenOutcome)
	{
		foreach (DecisionOutcome possibleOutcome in possibleOutcomes)
		{
			bool shouldSettlementOwnerChange = ((SettlementClaimantPreliminaryOutcome)possibleOutcome).ShouldSettlementOwnerChange;
			foreach (Supporter supporter in possibleOutcome.SupporterList)
			{
				if (supporter.Clan.Leader != _ownerClan.Leader)
				{
					ChangeRelationAction.ApplyRelationChangeBetweenHeroes(supporter.Clan.Leader, _ownerClan.Leader, Campaign.Current.Models.DiplomacyModel.GetRelationChangeAfterVotingInSettlementOwnerPreliminaryDecision(supporter.Clan.Leader, shouldSettlementOwnerChange));
				}
			}
		}
	}

	public override TextObject GetChosenOutcomeText(DecisionOutcome chosenOutcome, SupportStatus supportStatus, bool isShortVersion = false)
	{
		TextObject textObject = (((SettlementClaimantPreliminaryOutcome)chosenOutcome).ShouldSettlementOwnerChange ? (supportStatus switch
		{
			SupportStatus.Majority => new TextObject("{=Zo65bOpH}{RULER.NAME} has decided to give {SETTLEMENT} to a new clan with the support of with {?RULER.GENDER}her{?}his{\\?} council."), 
			SupportStatus.Minority => new TextObject("{=w3sfcpoa}{RULER.NAME} has decided to give {SETTLEMENT} to a new clan despite the opposition of {?RULER.GENDER}her{?}his{\\?} council"), 
			_ => new TextObject("{=JzALLCEX}{RULER.NAME} has decided to give {SETTLEMENT} to a new clan, with {?RULER.GENDER}her{?}his{\\?} council evenly split on the matter."), 
		}) : (supportStatus switch
		{
			SupportStatus.Majority => new TextObject("{=vkeHpUEB}{RULER.NAME} has decided against giving {SETTLEMENT} to a new clan with the support of with {?RULER.GENDER}her{?}his{\\?} council."), 
			SupportStatus.Minority => new TextObject("{=9Cbeagow}{RULER.NAME} has decided against giving {SETTLEMENT} to a new clan over the objections of {?RULER.GENDER}her{?}his{\\?} council."), 
			_ => new TextObject("{=fP8NHthR}{RULER.NAME} has decided against giving {SETTLEMENT} to a new clan, with {?RULER.GENDER}her{?}his{\\?} council evenly split on the matter."), 
		}));
		textObject.SetTextVariable("SETTLEMENT", Settlement.Name);
		textObject.SetTextVariable("KINGDOM", Settlement.MapFaction.InformalName);
		StringHelpers.SetCharacterProperties("RULER", Settlement.MapFaction.Leader.CharacterObject, textObject);
		return textObject;
	}

	public override DecisionOutcome GetQueriedDecisionOutcome(MBReadOnlyList<DecisionOutcome> possibleOutcomes)
	{
		return possibleOutcomes.FirstOrDefault((DecisionOutcome t) => ((SettlementClaimantPreliminaryOutcome)t).ShouldSettlementOwnerChange);
	}

	public override KingdomDecision GetFollowUpDecision()
	{
		return base.Kingdom.UnresolvedDecisions.FirstOrDefault((KingdomDecision x) => x is SettlementClaimantDecision settlementClaimantDecision && settlementClaimantDecision.Settlement == Settlement);
	}
}
