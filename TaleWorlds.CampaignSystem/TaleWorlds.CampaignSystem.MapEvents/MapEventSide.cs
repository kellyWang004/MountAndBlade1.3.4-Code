using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.CharacterDevelopment;
using TaleWorlds.CampaignSystem.Naval;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.CampaignSystem.Roster;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.CampaignSystem.Siege;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.LinQuick;
using TaleWorlds.Localization;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.CampaignSystem.MapEvents;

public class MapEventSide
{
	[CachedData]
	private List<(FlattenedTroopRosterElement, MapEventParty, float)> _readyTroopsPriorityList;

	[CachedData]
	private Dictionary<UniqueTroopDescriptor, MapEventParty> _readyTroopsTemporaryCache;

	[CachedData]
	private bool _requiresTroopCacheUpdate;

	[CachedData]
	private Dictionary<UniqueTroopDescriptor, MapEventParty> _allocatedTroops;

	[CachedData]
	private Dictionary<MapEventParty, float> _partyStrengthCache;

	[CachedData]
	internal float LeaderSimulationModifier;

	[CachedData]
	private MBList<(SiegeEngineType, Ship)> _siegeEngineList = new MBList<(SiegeEngineType, Ship)>();

	[SaveableField(30)]
	private readonly MBList<MapEventParty> _battleParties;

	[SaveableField(9)]
	public float StrengthRatio = 1f;

	[SaveableField(10)]
	public float RenownValue;

	[SaveableField(11)]
	public float InfluenceValue;

	[SaveableField(14)]
	public int TroopCasualties;

	[SaveableField(16)]
	private readonly MapEvent _mapEvent;

	[SaveableField(18)]
	public int ShipCasualties;

	[CachedData]
	private List<UniqueTroopDescriptor> _simulationTroopList;

	[SaveableField(130)]
	private IFaction _mapFaction;

	[SaveableField(23)]
	private int _selectedSimulationTroopIndex;

	[SaveableField(24)]
	private UniqueTroopDescriptor _selectedSimulationTroopDescriptor;

	[SaveableField(25)]
	private CharacterObject _selectedSimulationTroop;

	[SaveableField(26)]
	internal bool IsSurrendered;

	[SaveableField(27)]
	private MBList<MobileParty> _nearbyPartiesAddedToPlayerMapEvent = new MBList<MobileParty>();

	[CachedData]
	public MBList<Ship> SimulationShipList { get; private set; } = new MBList<Ship>();

	[CachedData]
	public float WeightedShipCombatFactor { get; private set; }

	[SaveableProperty(4)]
	public PartyBase LeaderParty { get; internal set; }

	public MBReadOnlyList<MapEventParty> Parties => _battleParties;

	[SaveableProperty(7)]
	public BattleSideEnum MissionSide { get; private set; }

	private IBattleObserver BattleObserver => _mapEvent.BattleObserver;

	public int TroopCount => RecalculateMemberCountOfSide();

	public bool HasReadyTroops
	{
		get
		{
			if (_readyTroopsPriorityList != null)
			{
				return _readyTroopsPriorityList.Count > 0;
			}
			return false;
		}
	}

	public int NumRemainingSimulationTroops => _simulationTroopList?.Count ?? 0;

	public int NumRemainingSimulationShips => SimulationShipList?.Count ?? 0;

	public int NumRemainingSimulationSiegeEngines => _siegeEngineList?.Count ?? 0;

	[SaveableProperty(15)]
	public float CasualtyStrength { get; private set; }

	public int HealthyTroopCountAtMapEventStart => _battleParties.Sum((MapEventParty x) => x.HealthyManCountAtStart);

	public MapEvent MapEvent => _mapEvent;

	public MapEventSide OtherSide => _mapEvent.GetMapEventSide((MissionSide == BattleSideEnum.Defender) ? BattleSideEnum.Attacker : BattleSideEnum.Defender);

	public IFaction MapFaction => _mapFaction ?? LeaderParty.MapFaction;

	internal static void AutoGeneratedStaticCollectObjectsMapEventSide(object o, List<object> collectedObjects)
	{
		((MapEventSide)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		collectedObjects.Add(_battleParties);
		collectedObjects.Add(_mapEvent);
		collectedObjects.Add(_mapFaction);
		UniqueTroopDescriptor.AutoGeneratedStaticCollectObjectsUniqueTroopDescriptor(_selectedSimulationTroopDescriptor, collectedObjects);
		collectedObjects.Add(_selectedSimulationTroop);
		collectedObjects.Add(_nearbyPartiesAddedToPlayerMapEvent);
		collectedObjects.Add(LeaderParty);
	}

	internal static object AutoGeneratedGetMemberValueLeaderParty(object o)
	{
		return ((MapEventSide)o).LeaderParty;
	}

	internal static object AutoGeneratedGetMemberValueMissionSide(object o)
	{
		return ((MapEventSide)o).MissionSide;
	}

	internal static object AutoGeneratedGetMemberValueCasualtyStrength(object o)
	{
		return ((MapEventSide)o).CasualtyStrength;
	}

	internal static object AutoGeneratedGetMemberValueStrengthRatio(object o)
	{
		return ((MapEventSide)o).StrengthRatio;
	}

	internal static object AutoGeneratedGetMemberValueRenownValue(object o)
	{
		return ((MapEventSide)o).RenownValue;
	}

	internal static object AutoGeneratedGetMemberValueInfluenceValue(object o)
	{
		return ((MapEventSide)o).InfluenceValue;
	}

	internal static object AutoGeneratedGetMemberValueTroopCasualties(object o)
	{
		return ((MapEventSide)o).TroopCasualties;
	}

	internal static object AutoGeneratedGetMemberValueShipCasualties(object o)
	{
		return ((MapEventSide)o).ShipCasualties;
	}

	internal static object AutoGeneratedGetMemberValueIsSurrendered(object o)
	{
		return ((MapEventSide)o).IsSurrendered;
	}

	internal static object AutoGeneratedGetMemberValue_battleParties(object o)
	{
		return ((MapEventSide)o)._battleParties;
	}

	internal static object AutoGeneratedGetMemberValue_mapEvent(object o)
	{
		return ((MapEventSide)o)._mapEvent;
	}

	internal static object AutoGeneratedGetMemberValue_mapFaction(object o)
	{
		return ((MapEventSide)o)._mapFaction;
	}

	internal static object AutoGeneratedGetMemberValue_selectedSimulationTroopIndex(object o)
	{
		return ((MapEventSide)o)._selectedSimulationTroopIndex;
	}

	internal static object AutoGeneratedGetMemberValue_selectedSimulationTroopDescriptor(object o)
	{
		return ((MapEventSide)o)._selectedSimulationTroopDescriptor;
	}

	internal static object AutoGeneratedGetMemberValue_selectedSimulationTroop(object o)
	{
		return ((MapEventSide)o)._selectedSimulationTroop;
	}

	internal static object AutoGeneratedGetMemberValue_nearbyPartiesAddedToPlayerMapEvent(object o)
	{
		return ((MapEventSide)o)._nearbyPartiesAddedToPlayerMapEvent;
	}

	public int CountTroops(Func<FlattenedTroopRosterElement, bool> pred)
	{
		int num = 0;
		foreach (MapEventParty battleParty in _battleParties)
		{
			foreach (FlattenedTroopRosterElement troop in battleParty.Troops)
			{
				if (pred(troop))
				{
					num++;
				}
			}
		}
		return num;
	}

	public int GetTotalHealthyTroopCountOfSide()
	{
		int num = 0;
		foreach (MapEventParty battleParty in _battleParties)
		{
			num += battleParty.Party.MemberRoster.TotalRegulars - battleParty.Party.MemberRoster.TotalWoundedRegulars;
		}
		return num;
	}

	public int GetTotalHealthyHeroCountOfSide()
	{
		int num = 0;
		foreach (MapEventParty battleParty in _battleParties)
		{
			TroopRoster memberRoster = battleParty.Party.MemberRoster;
			num += memberRoster.TotalHeroes - memberRoster.TotalWoundedHeroes;
		}
		return num;
	}

	internal MapEventSide(MapEvent mapEvent, BattleSideEnum missionSide, PartyBase leaderParty)
	{
		_mapEvent = mapEvent;
		LeaderParty = leaderParty;
		MissionSide = missionSide;
		_mapFaction = leaderParty.MapFaction;
		_battleParties = new MBList<MapEventParty>();
	}

	internal void CacheLeaderSimulationModifier()
	{
		LeaderSimulationModifier = LeaderParty.LeaderHero?.PowerModifier ?? 0f;
	}

	internal void AddPartyInternal(PartyBase party)
	{
		MapEventParty mapEventParty = new MapEventParty(party);
		_battleParties.Add(mapEventParty);
		_mapEvent.AddInvolvedPartyInternal(mapEventParty, MissionSide);
	}

	internal void RemovePartyInternal(PartyBase party)
	{
		int index = _battleParties.FindIndexQ((MapEventParty p) => p.Party == party);
		MapEventParty mapEventParty = _battleParties[index];
		_battleParties.RemoveAt(index);
		_mapEvent.RemoveInvolvedPartyInternal(mapEventParty);
		if (LeaderParty == party)
		{
			_mapFaction = LeaderParty.MapFaction;
			if (_battleParties.Count > 0)
			{
				LeaderParty = _battleParties[0].Party;
				_mapFaction = LeaderParty.MapFaction;
				CacheLeaderSimulationModifier();
			}
			else
			{
				MapEvent.FinalizeEvent();
			}
		}
	}

	public int RecalculateMemberCountOfSide()
	{
		int num = 0;
		foreach (MapEventParty party in Parties)
		{
			num += party.Party.NumberOfHealthyMembers;
		}
		return num;
	}

	public float RecalculateStrengthOfSide()
	{
		float num = 0f;
		foreach (MapEventParty party in Parties)
		{
			num += party.Party.GetCustomStrength(party.Party.Side, MapEvent.SimulationContext);
		}
		return num;
	}

	public bool IsMainPartyAmongParties()
	{
		return Parties.AnyQ((MapEventParty party) => party.Party == PartyBase.MainParty);
	}

	public float GetPlayerPartyContributionRate()
	{
		int num = CalculateTotalContribution();
		if (num == 0)
		{
			return 0f;
		}
		int num2 = 0;
		foreach (MapEventParty battleParty in _battleParties)
		{
			if (battleParty.Party == PartyBase.MainParty)
			{
				num2 = battleParty.ContributionToBattle;
				break;
			}
		}
		return (float)num2 / (float)num;
	}

	internal int CalculateTotalContribution()
	{
		int num = 0;
		foreach (MapEventParty battleParty in _battleParties)
		{
			if (battleParty.Party.MemberRoster.Count > 0)
			{
				num += battleParty.ContributionToBattle;
			}
		}
		return num;
	}

	public void CalculateRenownAndInfluenceValues(float[] strengthOfSide)
	{
		int missionSide = (int)MissionSide;
		int oppositeSide = (int)MissionSide.GetOppositeSide();
		float x = 1f;
		float num = 1f;
		if (_mapEvent.IsSiegeAssault)
		{
			float settlementAdvantage = Campaign.Current.Models.CombatSimulationModel.GetSettlementAdvantage(_mapEvent.MapEventSettlement);
			if (MissionSide == BattleSideEnum.Defender)
			{
				num = settlementAdvantage;
			}
			else
			{
				x = settlementAdvantage;
			}
		}
		float num2 = (_mapEvent.IsSiegeAssault ? 0.7f : ((_mapEvent.IsSallyOut || _mapEvent.IsRaid || _mapEvent.MapEventSettlement != null) ? 0.6f : 0.5f));
		StrengthRatio = (strengthOfSide[oppositeSide] * TaleWorlds.Library.MathF.Sqrt(x) + 10f) / (strengthOfSide[missionSide] * num + 10f);
		StrengthRatio = ((StrengthRatio > 10f) ? 10f : StrengthRatio);
		if (strengthOfSide[missionSide] > 0f)
		{
			RenownValue = TaleWorlds.Library.MathF.Pow(strengthOfSide[oppositeSide] * TaleWorlds.Library.MathF.Sqrt(x), 0.75f) * TaleWorlds.Library.MathF.Pow(StrengthRatio, 0.45f) * num2 * 0.75f;
			InfluenceValue = TaleWorlds.Library.MathF.Pow(strengthOfSide[oppositeSide] * TaleWorlds.Library.MathF.Sqrt(x), 0.75f) * TaleWorlds.Library.MathF.Pow(StrengthRatio, 0.15f) * 0.6f;
		}
	}

	internal void CommitXpGains()
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			battleParty.CommitXpGain();
		}
	}

	public virtual void DistributeRenownAndInfluence(MapEventResultExplainer resultExplainers = null)
	{
		int num = CalculateTotalContribution();
		if (num <= 0)
		{
			return;
		}
		float renownValue = RenownValue;
		float influenceValue = InfluenceValue;
		List<MobileParty> list = new List<MobileParty>();
		List<MobileParty> list2 = new List<MobileParty>();
		float num2 = _mapEvent.StrengthOfSide[(int)MissionSide.GetOppositeSide()];
		float num3 = num2;
		foreach (MapEventParty party3 in OtherSide.Parties)
		{
			num3 -= party3.Party.GetCustomStrength(party3.Party.Side, MapEvent.SimulationContext);
		}
		foreach (MapEventParty battleParty in _battleParties)
		{
			PartyBase party = battleParty.Party;
			if (party.IsMobile)
			{
				if (party.MobileParty.IsVillager)
				{
					list.Add(party.MobileParty);
				}
				else if (party.MobileParty.IsCaravan)
				{
					list2.Add(party.MobileParty);
				}
			}
		}
		foreach (MapEventParty battleParty2 in _battleParties)
		{
			PartyBase party2 = battleParty2.Party;
			float num4 = (float)battleParty2.ContributionToBattle / (float)num;
			if (party2.LeaderHero == null)
			{
				continue;
			}
			foreach (MobileParty item in list)
			{
				if (item.HomeSettlement.OwnerClan == party2.LeaderHero.Clan || item.HomeSettlement.OwnerClan.IsEliminated || party2.LeaderHero.Clan.IsEliminated)
				{
					continue;
				}
				int num5 = MBRandom.RoundRandomized(4f * num4);
				if (num5 > 0)
				{
					ChangeRelationAction.ApplyRelationChangeBetweenHeroes(item.HomeSettlement.OwnerClan.Leader, party2.LeaderHero.Clan.Leader, num5);
				}
				num5 = MBRandom.RoundRandomized(2f * num4);
				foreach (Hero notable in item.HomeSettlement.Notables)
				{
					ChangeRelationAction.ApplyRelationChangeBetweenHeroes(notable, party2.LeaderHero.Clan.Leader, num5);
				}
			}
			foreach (MobileParty item2 in list2)
			{
				if (item2.HomeSettlement != null && item2.HomeSettlement.OwnerClan != null && party2.LeaderHero != null && item2.HomeSettlement.OwnerClan.Leader.Clan != party2.LeaderHero.Clan && item2.Party.Owner != null && item2.Party.Owner != Hero.MainHero && item2.Party.Owner.IsAlive && party2.LeaderHero.Clan.Leader != null && party2.LeaderHero.Clan.Leader.IsAlive && !item2.IsCurrentlyUsedByAQuest)
				{
					int relationChange = MBRandom.RoundRandomized(6f * num4);
					ChangeRelationAction.ApplyRelationChangeBetweenHeroes(item2.Party.Owner, party2.LeaderHero.Clan.Leader, relationChange);
				}
			}
			if (MapEvent.IsRaid && MissionSide == BattleSideEnum.Defender && this == MapEvent.Winner && MapEvent.MapEventSettlement.Notables.Any())
			{
				ChangeRelationAction.ApplyRelationChangeBetweenHeroes(MapEvent.MapEventSettlement.Notables.GetRandomElement(), party2.LeaderHero, 5);
			}
			ExplainedNumber explainedNumber = Campaign.Current.Models.BattleRewardModel.CalculateRenownGain(party2, renownValue, num4);
			ExplainedNumber explainedNumber2 = Campaign.Current.Models.BattleRewardModel.CalculateInfluenceGain(party2, influenceValue, num4);
			ExplainedNumber moraleExplainedNumber = Campaign.Current.Models.BattleRewardModel.CalculateMoraleGainVictory(party2, renownValue, num4, MapEvent);
			battleParty2.GainedRenown = explainedNumber.ResultNumber * num3 / num2;
			battleParty2.GainedInfluence = explainedNumber2.ResultNumber * num3 / num2;
			battleParty2.MoraleChange = moraleExplainedNumber.ResultNumber;
			if (resultExplainers != null && Hero.MainHero == party2.LeaderHero)
			{
				resultExplainers.RenownExplainedNumber = new ExplainedNumber(battleParty2.GainedRenown);
				resultExplainers.InfluenceExplainedNumber = new ExplainedNumber(battleParty2.GainedInfluence);
				resultExplainers.MoraleExplainedNumber = moraleExplainedNumber;
			}
		}
	}

	public void ApplyRenownAndInfluenceChanges()
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			Hero leaderHero = battleParty.Party.LeaderHero;
			if (leaderHero != null)
			{
				if (battleParty.GainedRenown > 0.001f)
				{
					GainRenownAction.Apply(leaderHero, battleParty.GainedRenown, doNotNotify: true);
				}
				if (battleParty.GainedInfluence > 0.001f)
				{
					GainKingdomInfluenceAction.ApplyForBattle(leaderHero, battleParty.GainedInfluence);
				}
			}
		}
	}

	public float GetSideMorale()
	{
		float num = 0f;
		float num2 = 0f;
		if (_partyStrengthCache == null)
		{
			_partyStrengthCache = new Dictionary<MapEventParty, float>();
		}
		foreach (MapEventParty party in Parties)
		{
			if (party.Party.IsMobile)
			{
				float customStrength = party.Party.GetCustomStrength(MissionSide, MapEvent.SimulationContext);
				_partyStrengthCache[party] = customStrength;
				num += customStrength;
			}
		}
		foreach (MapEventParty party2 in Parties)
		{
			if (party2.Party.IsMobile)
			{
				float num3 = _partyStrengthCache[party2];
				if (num3 > 0f)
				{
					num2 += num3 / num * party2.Party.MobileParty.Morale;
				}
			}
		}
		if (MapEvent.EventType == MapEvent.BattleTypes.Siege && MissionSide == BattleSideEnum.Defender)
		{
			num2 = TaleWorlds.Library.MathF.Max(num2, 30f);
		}
		return num2;
	}

	public void ApplyFinalRewardsAndChanges()
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			PartyBase party = battleParty.Party;
			Hero leaderHero = party.LeaderHero;
			if (party.MobileParty != null)
			{
				party.MobileParty.RecentEventsMorale += battleParty.MoraleChange;
			}
			if (leaderHero != null)
			{
				if ((float)battleParty.PlunderedGold > 0.001f)
				{
					if (leaderHero == Hero.MainHero)
					{
						MBTextManager.SetTextVariable("GOLD", battleParty.PlunderedGold);
						MBInformationManager.AddQuickInformation(GameTexts.FindText("str_plunder_gain_message"));
					}
					GiveGoldAction.ApplyBetweenCharacters(null, leaderHero, battleParty.PlunderedGold, disableNotification: true);
				}
				if ((float)battleParty.GoldLost > 0.001f)
				{
					GiveGoldAction.ApplyBetweenCharacters(leaderHero, null, battleParty.GoldLost, disableNotification: true);
				}
			}
			else if (party.IsMobile && party.MobileParty.IsPartyTradeActive)
			{
				party.MobileParty.PartyTradeGold -= battleParty.GoldLost;
				party.MobileParty.PartyTradeGold += battleParty.PlunderedGold;
			}
		}
	}

	public void HandleMapEventEnd()
	{
		while (Parties.Count > 0)
		{
			MapEventParty mapEventParty = Parties.FirstOrDefault((MapEventParty x) => !x.Party.IsMobile || x.Party.MobileParty.Army == null || x.Party.MobileParty.Army.LeaderParty != x.Party.MobileParty) ?? Parties[Parties.Count - 1];
			HandleMapEventEndForPartyInternal(mapEventParty.Party);
		}
	}

	internal void HandleMapEventEndForPartyInternal(PartyBase party)
	{
		IEnumerable<TroopRosterElement> enumerable = party.MemberRoster.GetTroopRoster().WhereQ((TroopRosterElement x) => x.Character.IsHero && x.Character.HeroObject.IsAlive && x.Character.HeroObject.DeathMark == KillCharacterAction.KillCharacterActionDetail.DiedInBattle);
		PartyBase leaderParty = _mapEvent.GetLeaderParty(party.OpponentSide);
		bool flag = _mapEvent.IsWinnerSide(party.Side);
		party.MapEventSide = null;
		foreach (TroopRosterElement item in enumerable)
		{
			KillCharacterAction.ApplyByBattle(item.Character.HeroObject, OtherSide.LeaderParty.LeaderHero);
		}
		if (party.IsMobile && party != PartyBase.MainParty && party.IsActive && (party.NumberOfAllMembers == 0 || (!flag && !MapEvent.EndedByRetreat && (party.NumberOfHealthyMembers == 0 || (_mapEvent.BattleState != BattleState.None && party.MobileParty.IsMilitia)) && (party.MobileParty.Army == null || party.MobileParty.Army.LeaderParty.Party.NumberOfHealthyMembers == 0))) && (!party.MobileParty.IsDisbanding || party.MemberRoster.Count == 0))
		{
			if (party.LeaderHero != null)
			{
				party.LeaderHero.ChangeState(Hero.CharacterStates.Fugitive);
			}
			DestroyPartyAction.Apply(leaderParty, party.MobileParty);
		}
		party.MemberRoster.RemoveZeroCounts();
		party.PrisonRoster.RemoveZeroCounts();
		if (party.IsMobile && party.MobileParty.IsActive && party.MobileParty.CurrentSettlement == null)
		{
			party.SetVisualAsDirty();
		}
	}

	public static void AddHeroDamage(Hero character, int damage)
	{
		character.HitPoints -= damage;
	}

	public void AllocateShips()
	{
		if (!MapEvent.IsNavalMapEvent)
		{
			return;
		}
		if (SimulationShipList == null)
		{
			SimulationShipList = new MBList<Ship>();
		}
		else
		{
			SimulationShipList.Clear();
		}
		MBList<(Ship, MapEventParty)> mBList = new MBList<(Ship, MapEventParty)>();
		foreach (MapEventParty battleParty in _battleParties)
		{
			foreach (Ship ship in battleParty.Ships)
			{
				mBList.Add((ship, battleParty));
			}
		}
		CreateOrderedSimulationShipList(mBList);
		WeightedShipCombatFactor = GetWeightedShipCombatFactor();
	}

	public void AllocateSiegeEngines()
	{
		if (_siegeEngineList == null)
		{
			_siegeEngineList = new MBList<(SiegeEngineType, Ship)>();
		}
		else
		{
			_siegeEngineList.Clear();
		}
		if (!MapEvent.IsNavalMapEvent)
		{
			return;
		}
		for (int i = 0; i < SimulationShipList.Count; i++)
		{
			foreach (SiegeEngineType siegeEngine in SimulationShipList[i].GetSiegeEngines())
			{
				_siegeEngineList.Add((siegeEngine, SimulationShipList[i]));
			}
		}
	}

	private void CreateOrderedSimulationShipList(MBList<(Ship, MapEventParty)> ships)
	{
		float num = NumRemainingSimulationTroops;
		foreach (var item in ships.OrderByDescending(((Ship, MapEventParty) x) => GetShipCombatImportance(x.Item1)))
		{
			if (num <= 0f)
			{
				break;
			}
			float num2 = (float)item.Item1.MainDeckCrewCapacity * 0.8f;
			SimulationShipList.Add(item.Item1);
			num -= num2;
		}
	}

	private float GetShipCombatScore(Ship ship)
	{
		float combatFactor = ship.GetCombatFactor();
		float num = TaleWorlds.Library.MathF.Max(TaleWorlds.Library.MathF.Clamp(ship.HitPoints / ship.MaxHitPoints, 0f, 1f), 0.7f);
		return combatFactor * num;
	}

	private float GetShipCombatImportance(Ship ship)
	{
		float num = TaleWorlds.Library.MathF.Clamp(ship.HitPoints / ship.MaxHitPoints, 0f, 1f);
		float y = ((num < 0.3f) ? 2f : 0.6f);
		return GetShipCombatScore(ship) * TaleWorlds.Library.MathF.Pow(num, y);
	}

	public void AllocateTroops(ref List<UniqueTroopDescriptor> troopsList, int number = -1, Func<UniqueTroopDescriptor, MapEventParty, bool> customAllocationConditions = null)
	{
		if (troopsList == null)
		{
			troopsList = new List<UniqueTroopDescriptor>();
		}
		else
		{
			troopsList.Clear();
		}
		int num = ((number >= 0) ? number : int.MaxValue);
		int num2 = 0;
		int count = _readyTroopsPriorityList.Count;
		for (int i = 0; i < count; i++)
		{
			(FlattenedTroopRosterElement, MapEventParty, float) value = _readyTroopsPriorityList[i];
			UniqueTroopDescriptor descriptor = value.Item1.Descriptor;
			MapEventParty item = value.Item2;
			if (num > 0 && (customAllocationConditions == null || customAllocationConditions(descriptor, item)))
			{
				troopsList.Add(descriptor);
				_allocatedTroops.Add(descriptor, item);
				num--;
				if (BattleObserver != null)
				{
					BattleObserver.TroopNumberChanged(MissionSide, item.Party, item.Troops[descriptor].Troop, 1);
					_mapEvent.TroopUpgradeTracker.AddTrackedTroop(item.Party, item.Troops[descriptor].Troop);
				}
			}
			else
			{
				if (i != num2)
				{
					_readyTroopsPriorityList[num2] = value;
				}
				num2++;
			}
		}
		if (num2 < count)
		{
			_readyTroopsPriorityList.RemoveRange(num2, count - num2);
		}
		_requiresTroopCacheUpdate = true;
	}

	internal bool AllocateTroop(Func<UniqueTroopDescriptor, MapEventParty, bool> customAllocationConditions, out UniqueTroopDescriptor troopDescriptor)
	{
		troopDescriptor = default(UniqueTroopDescriptor);
		for (int i = 0; i < _readyTroopsPriorityList.Count; i++)
		{
			if (troopDescriptor.IsValid)
			{
				break;
			}
			(FlattenedTroopRosterElement, MapEventParty, float) tuple = _readyTroopsPriorityList[i];
			UniqueTroopDescriptor descriptor = tuple.Item1.Descriptor;
			MapEventParty item = tuple.Item2;
			if (customAllocationConditions == null || customAllocationConditions(descriptor, item))
			{
				troopDescriptor = descriptor;
				_allocatedTroops.Add(descriptor, item);
				if (BattleObserver != null)
				{
					BattleObserver.TroopNumberChanged(MissionSide, item.Party, item.Troops[descriptor].Troop, 1);
					_mapEvent.TroopUpgradeTracker.AddTrackedTroop(item.Party, item.Troops[descriptor].Troop);
				}
				_readyTroopsPriorityList.RemoveAt(i);
				_requiresTroopCacheUpdate = true;
				break;
			}
		}
		return troopDescriptor.IsValid;
	}

	public void GetAllTroops(ref List<UniqueTroopDescriptor> troopsList)
	{
		if (troopsList == null)
		{
			troopsList = new List<UniqueTroopDescriptor>();
		}
		else
		{
			troopsList.Clear();
		}
		foreach (var readyTroopsPriority in _readyTroopsPriorityList)
		{
			List<UniqueTroopDescriptor> obj = troopsList;
			var (flattenedTroopRosterElement, _, _) = readyTroopsPriority;
			obj.Add(flattenedTroopRosterElement.Descriptor);
		}
		foreach (UniqueTroopDescriptor key in _allocatedTroops.Keys)
		{
			troopsList.Add(key);
		}
	}

	public CharacterObject GetAllocatedTroop(UniqueTroopDescriptor troopDesc0)
	{
		if (_allocatedTroops.TryGetValue(troopDesc0, out var value))
		{
			return value.Troops[troopDesc0].Troop;
		}
		return null;
	}

	public CharacterObject GetReadyTroop(UniqueTroopDescriptor troopDesc0)
	{
		CheckReadyTroopsTemporaryCache();
		if (_readyTroopsTemporaryCache.TryGetValue(troopDesc0, out var value))
		{
			return value.Troops[troopDesc0].Troop;
		}
		return null;
	}

	public PartyBase GetAllocatedTroopParty(UniqueTroopDescriptor troopDescriptor)
	{
		if (_allocatedTroops.TryGetValue(troopDescriptor, out var value))
		{
			return value.Party;
		}
		return null;
	}

	public PartyBase GetReadyTroopParty(UniqueTroopDescriptor troopDescriptor)
	{
		CheckReadyTroopsTemporaryCache();
		if (_readyTroopsTemporaryCache.TryGetValue(troopDescriptor, out var value))
		{
			return value.Party;
		}
		return null;
	}

	public void OnTroopWounded(UniqueTroopDescriptor troopDesc1)
	{
		MapEventParty mapEventParty = _allocatedTroops[troopDesc1];
		mapEventParty.OnTroopWounded(troopDesc1);
		CharacterObject troop = mapEventParty.GetTroop(troopDesc1);
		float troopPower = Campaign.Current.Models.MilitaryPowerModel.GetTroopPower(troop, MissionSide, MapEvent.SimulationContext, LeaderSimulationModifier);
		CasualtyStrength += troopPower;
		TroopCasualties++;
	}

	public void OnTroopKilled(UniqueTroopDescriptor troopDesc1)
	{
		MapEventParty mapEventParty = _allocatedTroops[troopDesc1];
		mapEventParty.OnTroopKilled(troopDesc1);
		CharacterObject troop = mapEventParty.GetTroop(troopDesc1);
		float troopPower = Campaign.Current.Models.MilitaryPowerModel.GetTroopPower(troop, MissionSide, MapEvent.SimulationContext, LeaderSimulationModifier);
		CasualtyStrength += troopPower;
		TroopCasualties++;
	}

	public void OnTroopRouted(UniqueTroopDescriptor troopDesc1, bool isOrderRetreat)
	{
		MapEventParty mapEventParty = _allocatedTroops[troopDesc1];
		if (!isOrderRetreat && (MapEvent.EventType != MapEvent.BattleTypes.Siege || MissionSide == BattleSideEnum.Attacker))
		{
			mapEventParty.OnTroopRouted(troopDesc1);
		}
		CharacterObject troop = mapEventParty.GetTroop(troopDesc1);
		float troopPower = Campaign.Current.Models.MilitaryPowerModel.GetTroopPower(troop, MissionSide, MapEvent.SimulationContext, LeaderSimulationModifier);
		CasualtyStrength += troopPower * 0.1f;
		TroopCasualties++;
	}

	public void OnTroopScoreHit(UniqueTroopDescriptor troopDesc1, CharacterObject attackedTroop, int damage, bool isFatal, bool isTeamKill, WeaponComponentData attackerWeapon, bool isSimulatedHit)
	{
		_allocatedTroops[troopDesc1].OnTroopScoreHit(troopDesc1, attackedTroop, damage, isFatal, isTeamKill, attackerWeapon, isSimulatedHit);
	}

	public void OnShipScoreHit(Ship strikerShip, Ship struckShip, SiegeEngineType siegeEngine, int damage, bool isFinishingStrike)
	{
		GetMapEventParty(strikerShip.Owner).OnShipScoreHit(strikerShip, struckShip, siegeEngine, damage, isFinishingStrike);
	}

	public void OnShipDamaged(Ship struckShip, SiegeEngineType siegeEngine, int damage)
	{
		GetMapEventParty(struckShip.Owner).OnShipDamaged(struckShip, siegeEngine, damage);
		ShipCasualties += damage;
	}

	private float GetWeightedShipCombatFactor()
	{
		float num = 0f;
		float num2 = 0f;
		foreach (Ship simulationShip in SimulationShipList)
		{
			num2 += (float)simulationShip.MainDeckCrewCapacity;
			num += (float)simulationShip.MainDeckCrewCapacity * GetShipCombatScore(simulationShip);
		}
		if (!num2.ApproximatelyEqualsTo(0f))
		{
			return 0f;
		}
		return num / num2;
	}

	private MapEventParty GetMapEventParty(PartyBase partyBase)
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			if (battleParty.Party == partyBase)
			{
				return battleParty;
			}
		}
		return null;
	}

	private void MakeReady(bool includeHumanPlayers, FlattenedTroopRoster priorTroops = null, int sizeOfSide = -1)
	{
		bool flag = includeHumanPlayers;
		if (_readyTroopsPriorityList == null || _allocatedTroops == null)
		{
			_readyTroopsPriorityList = new List<(FlattenedTroopRosterElement, MapEventParty, float)>();
			_allocatedTroops = new Dictionary<UniqueTroopDescriptor, MapEventParty>();
		}
		else
		{
			_readyTroopsPriorityList.Clear();
			_allocatedTroops.Clear();
		}
		if (sizeOfSide <= 0)
		{
			sizeOfSide = 0;
			foreach (MapEventParty battleParty in _battleParties)
			{
				sizeOfSide += battleParty.Party.NumberOfHealthyMembers;
			}
		}
		foreach (MapEventParty battleParty2 in _battleParties)
		{
			MakeReadyParty(battleParty2, priorTroops, includeHumanPlayers, sizeOfSide);
		}
		if (flag)
		{
			_readyTroopsPriorityList.Sort(((FlattenedTroopRosterElement, MapEventParty, float) a, (FlattenedTroopRosterElement, MapEventParty, float) b) => b.Item3.CompareTo(a.Item3));
		}
		_requiresTroopCacheUpdate = true;
	}

	private void MakeReadyParty(MapEventParty battleParty, FlattenedTroopRoster priorityTroops, bool includePlayers, int sizeOfSide)
	{
		battleParty.Update();
		bool forcePriorityTroops = priorityTroops != null && _mapEvent.PlayerSide == MissionSide && (_mapEvent.IsHideoutBattle || (_mapEvent.IsSiegeAssault && PlayerSiege.BesiegedSettlement != null && PlayerSiege.BesiegedSettlement.CurrentSiegeState == Settlement.SiegeState.InTheLordsHall));
		Campaign.Current.Models.TroopSupplierProbabilityModel.EnqueueTroopSpawnProbabilitiesAccordingToUnitSpawnPrioritization(battleParty, priorityTroops, includePlayers, sizeOfSide, forcePriorityTroops, _readyTroopsPriorityList);
	}

	private void CheckReadyTroopsTemporaryCache()
	{
		if (_readyTroopsTemporaryCache == null)
		{
			_readyTroopsTemporaryCache = new Dictionary<UniqueTroopDescriptor, MapEventParty>();
		}
		if (!_requiresTroopCacheUpdate)
		{
			return;
		}
		_readyTroopsTemporaryCache.Clear();
		foreach (var readyTroopsPriority in _readyTroopsPriorityList)
		{
			Dictionary<UniqueTroopDescriptor, MapEventParty> readyTroopsTemporaryCache = _readyTroopsTemporaryCache;
			var (flattenedTroopRosterElement, _, _) = readyTroopsPriority;
			readyTroopsTemporaryCache.Add(flattenedTroopRosterElement.Descriptor, readyTroopsPriority.Item2);
		}
		_requiresTroopCacheUpdate = false;
	}

	public void MakeReadyForSimulation(FlattenedTroopRoster priorTroops, int sizeOfSide = -1)
	{
		MakeReady(includeHumanPlayers: false, priorTroops, sizeOfSide);
		AllocateTroops(ref _simulationTroopList, sizeOfSide);
		AllocateShips();
		AllocateSiegeEngines();
	}

	public void MakeReadyForMission(FlattenedTroopRoster priorTroops)
	{
		MakeReady(includeHumanPlayers: true, priorTroops);
	}

	public void EndSimulation()
	{
		_simulationTroopList.Clear();
		_readyTroopsPriorityList.Clear();
		_requiresTroopCacheUpdate = true;
		_allocatedTroops.Clear();
		SimulationShipList?.Clear();
	}

	internal void ResetContributionToBattleToStrength()
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			battleParty.ResetContributionToBattleToStrength();
		}
	}

	public ItemRoster ItemRosterForPlayerLootShare(PartyBase playerParty)
	{
		int index = _battleParties.FindIndexQ((MapEventParty p) => p.Party == playerParty);
		return _battleParties[index].RosterToReceiveLootItems;
	}

	public TroopRoster MemberRosterForPlayerLootShare(PartyBase playerParty)
	{
		int index = _battleParties.FindIndexQ((MapEventParty p) => p.Party == playerParty);
		return _battleParties[index].RosterToReceiveLootMembers;
	}

	public TroopRoster PrisonerRosterForPlayerLootShare(PartyBase playerParty)
	{
		int index = _battleParties.FindIndexQ((MapEventParty p) => p.Party == playerParty);
		return _battleParties[index].RosterToReceiveLootPrisoners;
	}

	public void Clear()
	{
		_battleParties.Clear();
	}

	public UniqueTroopDescriptor SelectRandomSimulationTroop()
	{
		_selectedSimulationTroopIndex = MBRandom.RandomInt(NumRemainingSimulationTroops);
		_selectedSimulationTroopDescriptor = _simulationTroopList[_selectedSimulationTroopIndex];
		_selectedSimulationTroop = GetAllocatedTroop(_selectedSimulationTroopDescriptor);
		return _selectedSimulationTroopDescriptor;
	}

	public (SiegeEngineType, Ship) GetRandomSimulationSiegeEngine()
	{
		if (NumRemainingSimulationSiegeEngines > 0)
		{
			return _siegeEngineList[MBRandom.RandomInt(NumRemainingSimulationSiegeEngines)];
		}
		return (null, null);
	}

	public Ship GetRandomSimulationShip()
	{
		if (NumRemainingSimulationShips > 0)
		{
			return SimulationShipList[MBRandom.RandomInt(NumRemainingSimulationShips)];
		}
		return null;
	}

	private void RemoveSelectedTroopFromSimulationList()
	{
		_simulationTroopList[_selectedSimulationTroopIndex] = _simulationTroopList[_simulationTroopList.Count - 1];
		_simulationTroopList.RemoveAt(_simulationTroopList.Count - 1);
		_selectedSimulationTroopIndex = -1;
		_selectedSimulationTroopDescriptor = UniqueTroopDescriptor.Invalid;
		_selectedSimulationTroop = null;
	}

	private void RemoveShipFromSimulationList(Ship ship)
	{
		SimulationShipList.Remove(ship);
		for (int num = _siegeEngineList.Count - 1; num >= 0; num--)
		{
			if (_siegeEngineList[num].Item2 == ship)
			{
				_siegeEngineList.RemoveAt(num);
			}
		}
	}

	internal void OnRoundEnd(BattleSideEnum roundWinner)
	{
		foreach (MapEventParty battleParty in _battleParties)
		{
			battleParty.OnRoundEnd(this, roundWinner);
		}
	}

	internal bool ApplySimulationDamageToShip(int damage, Ship struckShip, SiegeEngineType siegeEngine, PartyBase strikerParty)
	{
		MapEventParty mapEventParty = GetMapEventParty(struckShip.Owner);
		OnShipDamaged(struckShip, siegeEngine, damage);
		bool num = struckShip.HitPoints <= 0f;
		if (num)
		{
			mapEventParty.OnShipSunk(struckShip);
			RemoveShipFromSimulationList(struckShip);
		}
		return num;
	}

	internal bool ApplySimulationDamageToSelectedTroop(int damage, DamageTypes damageType, PartyBase strikerParty)
	{
		bool flag = false;
		if (_selectedSimulationTroop.IsHero)
		{
			AddHeroDamage(_selectedSimulationTroop.HeroObject, damage);
			if (_selectedSimulationTroop.HeroObject.IsWounded)
			{
				float survivalChance = Campaign.Current.Models.PartyHealingModel.GetSurvivalChance(_selectedSimulationTroop.HeroObject.PartyBelongedTo?.Party ?? null, _selectedSimulationTroop, damageType, canDamageKillEvenIfBlunt: false, strikerParty);
				if (MBRandom.RandomFloat > survivalChance && _selectedSimulationTroop.HeroObject.CanDie(KillCharacterAction.KillCharacterActionDetail.DiedInBattle))
				{
					OnTroopKilled(_selectedSimulationTroopDescriptor);
					BattleObserver?.TroopNumberChanged(MissionSide, GetAllocatedTroopParty(_selectedSimulationTroopDescriptor), _selectedSimulationTroop, -1, 1);
					KillCharacterAction.ApplyByBattle(_selectedSimulationTroop.HeroObject, null, showNotification: false);
				}
				else
				{
					OnTroopWounded(_selectedSimulationTroopDescriptor);
					BattleObserver?.TroopNumberChanged(MissionSide, GetAllocatedTroopParty(_selectedSimulationTroopDescriptor), _selectedSimulationTroop, -1, 0, 1);
				}
				flag = true;
			}
		}
		else if (MBRandom.RandomInt(_selectedSimulationTroop.MaxHitPoints()) < damage)
		{
			PartyBase party = _allocatedTroops[_selectedSimulationTroopDescriptor].Party;
			float survivalChance2 = Campaign.Current.Models.PartyHealingModel.GetSurvivalChance(party, _selectedSimulationTroop, damageType, canDamageKillEvenIfBlunt: false, strikerParty);
			if (MBRandom.RandomFloat < survivalChance2)
			{
				OnTroopWounded(_selectedSimulationTroopDescriptor);
				BattleObserver?.TroopNumberChanged(MissionSide, GetAllocatedTroopParty(_selectedSimulationTroopDescriptor), _selectedSimulationTroop, -1, 0, 1);
				SkillLevelingManager.OnSurgeryApplied(party.MobileParty, surgerySuccess: true, _selectedSimulationTroop.Tier);
				if (strikerParty?.MobileParty != null && strikerParty.MobileParty.HasPerk(DefaultPerks.Medicine.DoctorsOath))
				{
					SkillLevelingManager.OnSurgeryApplied(strikerParty.MobileParty, surgerySuccess: true, _selectedSimulationTroop.Tier);
				}
			}
			else
			{
				OnTroopKilled(_selectedSimulationTroopDescriptor);
				BattleObserver?.TroopNumberChanged(MissionSide, GetAllocatedTroopParty(_selectedSimulationTroopDescriptor), _selectedSimulationTroop, -1, 1);
				SkillLevelingManager.OnSurgeryApplied(party.MobileParty, surgerySuccess: false, _selectedSimulationTroop.Tier);
				if (strikerParty?.MobileParty != null && strikerParty.MobileParty.HasPerk(DefaultPerks.Medicine.DoctorsOath))
				{
					SkillLevelingManager.OnSurgeryApplied(strikerParty.MobileParty, surgerySuccess: false, _selectedSimulationTroop.Tier);
				}
			}
			flag = true;
		}
		if (flag)
		{
			RemoveSelectedTroopFromSimulationList();
		}
		return flag;
	}

	internal void ApplySimulatedHitRewardToShip(Ship strikerShip, Ship struckShip, SiegeEngineType siegeEngine, int damage, bool isFinishingStrike)
	{
		OnShipScoreHit(strikerShip, struckShip, siegeEngine, damage, isFinishingStrike);
	}

	internal void ApplySimulatedHitRewardToSelectedTroop(CharacterObject strikerTroop, CharacterObject attackedTroop, int damage, bool isFinishingStrike)
	{
		EquipmentElement equipmentElement = strikerTroop.FirstBattleEquipment[EquipmentIndex.WeaponItemBeginSlot];
		OnTroopScoreHit(_selectedSimulationTroopDescriptor, attackedTroop, damage, isFinishingStrike, isTeamKill: false, equipmentElement.Item?.PrimaryWeapon, isSimulatedHit: true);
		PartyBase party = _allocatedTroops[_selectedSimulationTroopDescriptor].Party;
		if (isFinishingStrike && (!attackedTroop.IsHero || !attackedTroop.HeroObject.IsDead))
		{
			SkillLevelingManager.OnSimulationCombatKill(_selectedSimulationTroop, attackedTroop, party, LeaderParty);
		}
		if (BattleObserver == null)
		{
			return;
		}
		if (isFinishingStrike)
		{
			BattleObserver.TroopNumberChanged(MissionSide, party, _selectedSimulationTroop, 0, 0, 0, 0, 1);
		}
		if (_selectedSimulationTroop.IsHero)
		{
			foreach (SkillObject item in _mapEvent.TroopUpgradeTracker.CheckSkillUpgrades(_selectedSimulationTroop.HeroObject).ToList())
			{
				BattleObserver.HeroSkillIncreased(MissionSide, party, _selectedSimulationTroop, item);
			}
			return;
		}
		int num = _mapEvent.TroopUpgradeTracker.CheckUpgradedCount(party, _selectedSimulationTroop);
		if (num != 0)
		{
			BattleObserver.TroopNumberChanged(MissionSide, party, _selectedSimulationTroop, 0, 0, 0, 0, 0, num);
		}
	}

	public void Surrender()
	{
		SurrenderParty(LeaderParty);
		IsSurrendered = true;
	}

	public void Route()
	{
		List<UniqueTroopDescriptor> troopsList = new List<UniqueTroopDescriptor>();
		GetAllTroops(ref troopsList);
		foreach (UniqueTroopDescriptor item in troopsList)
		{
			if (_allocatedTroops.TryGetValue(item, out var value) && value.GetTroopState(item) == RosterTroopState.Active)
			{
				OnTroopRouted(item, isOrderRetreat: false);
				BattleObserver?.TroopNumberChanged(MissionSide, value.Party, value.GetTroop(item), -1, 0, 0, 1);
			}
		}
	}

	private static void SurrenderParty(PartyBase party)
	{
		for (int i = 0; i < party.MemberRoster.Count; i++)
		{
			TroopRosterElement elementCopyAtIndex = party.MemberRoster.GetElementCopyAtIndex(i);
			if (!elementCopyAtIndex.Character.IsHero)
			{
				party.MemberRoster.AddToCountsAtIndex(i, 0, elementCopyAtIndex.Number - elementCopyAtIndex.WoundedNumber);
			}
		}
	}

	internal void AddNearbyPartyToPlayerMapEvent(MobileParty party)
	{
		if (party.MapEventSide != this)
		{
			party.MapEventSide = this;
			_nearbyPartiesAddedToPlayerMapEvent.Add(party);
			CampaignEventDispatcher.Instance.OnNearbyPartyAddedToPlayerMapEvent(party);
		}
	}

	internal void RemoveNearbyPartiesFromPlayerMapEvent()
	{
		foreach (MobileParty item in _nearbyPartiesAddedToPlayerMapEvent)
		{
			item.MapEventSide = null;
		}
		_nearbyPartiesAddedToPlayerMapEvent.Clear();
	}
}
