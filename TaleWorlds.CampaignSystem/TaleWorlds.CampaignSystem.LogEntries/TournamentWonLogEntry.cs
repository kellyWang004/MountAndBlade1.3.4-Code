using System.Collections.Generic;
using Helpers;
using TaleWorlds.CampaignSystem.Settlements;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.CampaignSystem.LogEntries;

public class TournamentWonLogEntry : LogEntry, IEncyclopediaLog, IChatNotification
{
	[SaveableField(934)]
	private MBReadOnlyDictionary<Hero, short> _participants;

	[SaveableProperty(931)]
	public Hero Winner { get; private set; }

	[SaveableProperty(932)]
	public Town Town { get; private set; }

	public bool IsVisibleNotification => true;

	public override ChatNotificationType NotificationType => CivilianNotification(Winner.Clan);

	internal static void AutoGeneratedStaticCollectObjectsTournamentWonLogEntry(object o, List<object> collectedObjects)
	{
		((TournamentWonLogEntry)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		base.AutoGeneratedInstanceCollectObjects(collectedObjects);
		collectedObjects.Add(_participants);
		collectedObjects.Add(Winner);
		collectedObjects.Add(Town);
	}

	internal static object AutoGeneratedGetMemberValueWinner(object o)
	{
		return ((TournamentWonLogEntry)o).Winner;
	}

	internal static object AutoGeneratedGetMemberValueTown(object o)
	{
		return ((TournamentWonLogEntry)o).Town;
	}

	internal static object AutoGeneratedGetMemberValue_participants(object o)
	{
		return ((TournamentWonLogEntry)o)._participants;
	}

	public TournamentWonLogEntry(Hero winner, Town town, MBReadOnlyList<CharacterObject> gameParticipants)
	{
		Winner = winner;
		Town = town;
		Dictionary<Hero, short> dictionary = new Dictionary<Hero, short>();
		foreach (CharacterObject gameParticipant in gameParticipants)
		{
			if (gameParticipant.HeroObject != null && !dictionary.ContainsKey(gameParticipant.HeroObject))
			{
				dictionary.Add(gameParticipant.HeroObject, 1);
			}
		}
		_participants = dictionary.GetReadOnlyDictionary();
	}

	public override string ToString()
	{
		return "Tournament won";
	}

	public TextObject GetEncyclopediaText()
	{
		return GetNotificationText();
	}

	public TextObject GetNotificationText()
	{
		TextObject textObject = new TextObject("{=4ADQ7YZj}{PERSON.LINK} won the tournament at {TOWN}.");
		StringHelpers.SetCharacterProperties("PERSON", Winner.CharacterObject, textObject);
		textObject.SetTextVariable("TOWN", Town.Name);
		return textObject;
	}

	public bool IsVisibleInEncyclopediaPageOf<T>(T obj) where T : MBObjectBase
	{
		if ((object)obj != Winner && (object)obj != Winner.Clan)
		{
			return (object)obj == Town.Settlement;
		}
		return true;
	}

	public override void GetConversationScoreAndComment(Hero talkTroop, bool findString, out string comment, out ImportanceEnum score)
	{
		if (!_participants.TryGetValue(talkTroop, out var value))
		{
			value = -2;
		}
		if (!_participants.TryGetValue(Hero.MainHero, out var value2))
		{
			value2 = -2;
		}
		score = ImportanceEnum.Zero;
		comment = "";
		if (value <= 0 || value2 <= 0)
		{
			return;
		}
		score = ImportanceEnum.SomewhatImportant;
		if (!findString)
		{
			return;
		}
		MBTextManager.SetTextVariable("TOURNAMENT_TOWN", Town.Name);
		MBTextManager.SetTextVariable("TOURNAMENT_WINNER", Winner.Name);
		if (Winner == Hero.MainHero)
		{
			comment = "str_comment_you_won_tournament_elsewhere";
			if (Town.Settlement == Settlement.CurrentSettlement)
			{
				comment = "str_comment_you_won_tournament_here";
			}
		}
		else if (Winner == talkTroop)
		{
			comment = "str_comment_i_won_tournament_elsewhere";
			if (Town.Settlement == Settlement.CurrentSettlement)
			{
				comment = "str_comment_i_won_tournament_here";
			}
		}
		else
		{
			comment = "str_comment_someone_else_won_tournament_elsewhere";
			if (Town.Settlement == Settlement.CurrentSettlement)
			{
				comment = "str_comment_someone_else_won_tournament_here";
			}
		}
	}

	public override bool IsValid()
	{
		if (Winner != null)
		{
			if (Winner.IsWanderer)
			{
				return Winner.IsAlive;
			}
			return true;
		}
		return false;
	}
}
