using System;
using System.Collections.Generic;
using System.Xml;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

namespace TaleWorlds.Core;

public class HorseComponent : ItemComponent
{
	public struct MaterialProperty
	{
		public List<Tuple<uint, float>> MeshMultiplier;

		public string Name { get; private set; }

		public MaterialProperty(string name)
		{
			Name = name;
			MeshMultiplier = new List<Tuple<uint, float>>();
		}
	}

	public TextObject ModifiedName;

	public List<KeyValuePair<string, bool>> AdditionalMeshesNameList;

	private readonly MBList<MaterialProperty> _monsterMaterialNames;

	public Monster Monster { get; private set; }

	public int Maneuver { get; private set; }

	public int ChargeDamage { get; private set; }

	public int Speed { get; private set; }

	public int BodyLength { get; private set; }

	public int HitPoints => Monster.HitPoints;

	public int HitPointBonus { get; private set; }

	public bool IsRideable { get; private set; }

	public bool IsPackAnimal { get; private set; }

	public bool IsMount
	{
		get
		{
			if (IsRideable)
			{
				return !IsPackAnimal;
			}
			return false;
		}
	}

	public bool IsLiveStock
	{
		get
		{
			if (!IsRideable)
			{
				return !IsPackAnimal;
			}
			return false;
		}
	}

	public MBReadOnlyList<MaterialProperty> HorseMaterialNames => _monsterMaterialNames;

	public int MeatCount
	{
		get
		{
			if (!IsRideable)
			{
				if (Speed <= 20)
				{
					if (Speed <= 11)
					{
						return 2;
					}
					return 1;
				}
				return 4;
			}
			return 3;
		}
	}

	public int HideCount
	{
		get
		{
			if (!IsRideable)
			{
				if (Speed <= 20)
				{
					return 0;
				}
				return 2;
			}
			return 0;
		}
	}

	public SkeletonScale SkeletonScale { get; private set; }

	internal static void AutoGeneratedStaticCollectObjectsHorseComponent(object o, List<object> collectedObjects)
	{
		((HorseComponent)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		base.AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	public HorseComponent()
	{
		Maneuver = 0;
		ChargeDamage = 0;
		Speed = 0;
		BodyLength = 0;
		HitPointBonus = 0;
		ModifiedName = null;
		_monsterMaterialNames = new MBList<MaterialProperty>();
		AdditionalMeshesNameList = new List<KeyValuePair<string, bool>>();
		SkeletonScale = null;
	}

	public override ItemComponent GetCopy()
	{
		return new HorseComponent
		{
			Maneuver = Maneuver,
			ChargeDamage = ChargeDamage,
			Speed = Speed,
			BodyLength = BodyLength
		};
	}

	public override void Deserialize(MBObjectManager objectManager, XmlNode node)
	{
		base.Deserialize(objectManager, node);
		Maneuver = XmlHelper.ReadInt(node, "maneuver");
		ChargeDamage = XmlHelper.ReadInt(node, "charge_damage");
		Speed = XmlHelper.ReadInt(node, "speed");
		BodyLength = XmlHelper.ReadInt(node, "body_length");
		IsRideable = XmlHelper.ReadBool(node, "is_mountable");
		IsPackAnimal = XmlHelper.ReadBool(node, "is_pack_animal");
		Monster = (Monster)objectManager.ReadObjectReferenceFromXml("monster", typeof(Monster), node);
		HitPointBonus = XmlHelper.ReadInt(node, "extra_health");
		string text = node.Attributes["skeleton_scale"]?.Value;
		if (text != null)
		{
			SkeletonScale = Game.Current.ObjectManager.GetObject<SkeletonScale>(text);
		}
		foreach (XmlNode childNode in node.ChildNodes)
		{
			if (childNode.Name == "Materials")
			{
				foreach (XmlNode childNode2 in childNode.ChildNodes)
				{
					if (!(childNode2.Name == "Material"))
					{
						continue;
					}
					string value = childNode2.Attributes["name"].Value;
					_monsterMaterialNames.Add(new MaterialProperty(value));
					foreach (XmlNode childNode3 in childNode2.ChildNodes)
					{
						if (!(childNode3.Name == "MeshMultipliers"))
						{
							continue;
						}
						foreach (XmlNode childNode4 in childNode3.ChildNodes)
						{
							if (childNode4.Name == "MeshMultiplier")
							{
								uint item = ((childNode4.Attributes["mesh_multiplier"] != null) ? Convert.ToUInt32(childNode4.Attributes["mesh_multiplier"].Value, 16) : 0u);
								float item2 = ((childNode4.Attributes["percentage"] != null) ? ((float)Convert.ToDouble(childNode4.Attributes["percentage"].Value)) : 0f);
								_monsterMaterialNames[_monsterMaterialNames.Count - 1].MeshMultiplier.Add(new Tuple<uint, float>(item, item2));
							}
						}
					}
					_monsterMaterialNames[_monsterMaterialNames.Count - 1].MeshMultiplier.Sort((Tuple<uint, float> x, Tuple<uint, float> y) => x.Item2.CompareTo(y.Item2));
				}
			}
			else
			{
				if (!(childNode.Name == "AdditionalMeshes"))
				{
					continue;
				}
				foreach (XmlNode childNode5 in childNode.ChildNodes)
				{
					if (childNode5.Name == "Mesh" && childNode5.Attributes["name"] != null)
					{
						bool result = false;
						if (childNode5.Attributes["affected_by_cover"] != null)
						{
							result = bool.TryParse(childNode5.Attributes["affected_by_cover"].InnerText, out result);
						}
						AdditionalMeshesNameList.Add(new KeyValuePair<string, bool>(childNode5.Attributes["name"].InnerText, result));
					}
				}
			}
		}
	}
}
