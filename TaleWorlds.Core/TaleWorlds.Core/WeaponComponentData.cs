using System;
using System.Collections.Generic;
using System.Xml;
using TaleWorlds.Library;

namespace TaleWorlds.Core;

public class WeaponComponentData
{
	public enum WeaponTiers
	{
		Tier1,
		Tier2,
		Tier3,
		Tier4,
		Special
	}

	public WeaponFlags WeaponFlags;

	public WeaponTiers WeaponTier { get; private set; }

	public string WeaponDescriptionId { get; private set; }

	public int BodyArmor { get; private set; }

	public string PhysicsMaterial { get; private set; }

	public string FlyingSoundCode { get; private set; }

	public string PassbySoundCode { get; private set; }

	public string ItemUsage { get; private set; }

	public int ThrustSpeed { get; private set; }

	public int SwingSpeed { get; private set; }

	public int MissileSpeed { get; private set; }

	public int WeaponLength { get; private set; }

	public float WeaponBalance { get; private set; }

	public int ThrustDamage { get; private set; }

	public DamageTypes ThrustDamageType { get; private set; }

	public int SwingDamage { get; private set; }

	public DamageTypes SwingDamageType { get; private set; }

	public int FireDamage { get; private set; }

	public int Accuracy { get; private set; }

	public WeaponClass WeaponClass { get; private set; }

	public WeaponClass AmmoClass { get; private set; }

	public int MissileDamage => ThrustDamage;

	public float TotalInertia { get; private set; }

	public float CenterOfMass { get; private set; }

	public Vec3 CenterOfMass3D { get; private set; }

	public float SwingDamageFactor { get; private set; }

	public float ThrustDamageFactor { get; private set; }

	public int Handling { get; private set; }

	public float SweetSpotReach { get; private set; }

	public string TrailParticleName { get; private set; }

	public MatrixFrame StickingFrame { get; private set; }

	public Vec3 AmmoOffset { get; private set; }

	public short MaxDataValue { get; private set; }

	public MatrixFrame Frame { get; private set; }

	public Vec3 RotationSpeed { get; private set; }

	public short ReloadPhaseCount { get; private set; }

	public bool IsMeleeWeapon => WeaponFlags.HasAllFlags(WeaponFlags.MeleeWeapon);

	public bool IsRangedWeapon => WeaponFlags.HasAllFlags(WeaponFlags.RangedWeapon);

	public bool IsPolearm => WeaponFlags.HasAllFlags(WeaponFlags.MeleeWeapon | WeaponFlags.WideGrip);

	public bool IsConsumable => WeaponFlags.HasAllFlags(WeaponFlags.Consumable);

	public bool IsAmmo
	{
		get
		{
			if (!WeaponFlags.HasAnyFlag(WeaponFlags.WeaponMask))
			{
				return IsConsumable;
			}
			return false;
		}
	}

	public bool IsShield
	{
		get
		{
			if (!WeaponFlags.HasAnyFlag(WeaponFlags.WeaponMask))
			{
				return WeaponFlags.HasAllFlags(WeaponFlags.HasHitPoints | WeaponFlags.CanBlockRanged);
			}
			return false;
		}
	}

	public bool IsTwoHanded => WeaponFlags.HasAllFlags(WeaponFlags.MeleeWeapon | WeaponFlags.NotUsableWithOneHand);

	public bool IsOneHanded
	{
		get
		{
			if (WeaponFlags.HasAnyFlag(WeaponFlags.MeleeWeapon))
			{
				return !IsTwoHanded;
			}
			return false;
		}
	}

	public bool IsBow => WeaponFlags.HasAllFlags(WeaponFlags.StringHeldByHand | WeaponFlags.AutoReload);

	public bool IsCrossBow
	{
		get
		{
			if (WeaponFlags.HasAnyFlag(WeaponFlags.HasString))
			{
				return !IsBow;
			}
			return false;
		}
	}

	public SkillObject RelevantSkill => GetRelevantSkillFromWeaponClass(WeaponClass);

	public bool CanHitMultipleTargets
	{
		get
		{
			if (WeaponClass != WeaponClass.TwoHandedAxe)
			{
				return WeaponClass == WeaponClass.TwoHandedMace;
			}
			return true;
		}
	}

	internal static void AutoGeneratedStaticCollectObjectsWeaponComponentData(object o, List<object> collectedObjects)
	{
		((WeaponComponentData)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
	}

	public void Init(string weaponUsageName, string physicsMaterial, string itemUsage, DamageTypes thrustDamageType, DamageTypes swingDamageType, int bodyArmor, int weaponLength, float weaponBalance, float inertia, float centerOfMass, int handling, float swingDamageFactor, float thrustDamageFactor, short maxDataValue, string passBySoundCode, int accuracy, int missileSpeed, MatrixFrame stickingFrame, WeaponClass ammoClass, float sweetSpot, int swingSpeed, int swingDamage, int thrustSpeed, int thrustDamage, Vec3 rotationSpeed, WeaponTiers tier, short reloadPhaseCount)
	{
		WeaponDescriptionId = weaponUsageName;
		PhysicsMaterial = physicsMaterial;
		ItemUsage = itemUsage;
		ThrustDamageType = thrustDamageType;
		SwingDamageType = swingDamageType;
		BodyArmor = bodyArmor;
		WeaponLength = weaponLength;
		WeaponBalance = weaponBalance;
		TotalInertia = inertia * (float)((!IsConsumable) ? 1 : maxDataValue);
		CenterOfMass = centerOfMass;
		Handling = handling;
		SwingDamageFactor = swingDamageFactor;
		ThrustDamageFactor = thrustDamageFactor;
		MaxDataValue = maxDataValue;
		PassbySoundCode = passBySoundCode;
		Accuracy = accuracy;
		MissileSpeed = missileSpeed;
		StickingFrame = stickingFrame;
		AmmoClass = ammoClass;
		SweetSpotReach = sweetSpot;
		SwingSpeed = swingSpeed;
		SwingDamage = swingDamage;
		ThrustSpeed = thrustSpeed;
		ThrustDamage = thrustDamage;
		Frame = MatrixFrame.Identity;
		CenterOfMass3D = new Vec3(0f, 0f, centerOfMass);
		RotationSpeed = rotationSpeed;
		WeaponTier = tier;
		ReloadPhaseCount = reloadPhaseCount;
	}

	public void SetFrame(MatrixFrame frame)
	{
		Frame = frame;
	}

	public void SetAmmoOffset(Vec3 ammoOffset)
	{
		AmmoOffset = ammoOffset;
	}

	public static SkillObject GetRelevantSkillFromWeaponClass(WeaponClass weaponClass)
	{
		SkillObject result = null;
		switch (weaponClass)
		{
		case WeaponClass.Arrow:
		case WeaponClass.Bow:
			result = DefaultSkills.Bow;
			break;
		case WeaponClass.Bolt:
		case WeaponClass.Crossbow:
			result = DefaultSkills.Crossbow;
			break;
		case WeaponClass.SlingStone:
		case WeaponClass.Sling:
		case WeaponClass.Stone:
		case WeaponClass.Boulder:
		case WeaponClass.ThrowingAxe:
		case WeaponClass.ThrowingKnife:
		case WeaponClass.Javelin:
		case WeaponClass.BallistaBoulder:
		case WeaponClass.BallistaStone:
			result = DefaultSkills.Throwing;
			break;
		case WeaponClass.Dagger:
		case WeaponClass.OneHandedSword:
		case WeaponClass.OneHandedAxe:
		case WeaponClass.Mace:
			result = DefaultSkills.OneHanded;
			break;
		case WeaponClass.TwoHandedSword:
		case WeaponClass.TwoHandedAxe:
		case WeaponClass.TwoHandedMace:
			result = DefaultSkills.TwoHanded;
			break;
		case WeaponClass.OneHandedPolearm:
		case WeaponClass.TwoHandedPolearm:
		case WeaponClass.LowGripPolearm:
			result = DefaultSkills.Polearm;
			break;
		case WeaponClass.SmallShield:
		case WeaponClass.LargeShield:
			result = DefaultSkills.OneHanded;
			break;
		}
		return result;
	}

	public static ItemObject.ItemTypeEnum GetItemTypeFromWeaponClass(WeaponClass weaponClass)
	{
		switch (weaponClass)
		{
		case WeaponClass.Undefined:
		case WeaponClass.NumClasses:
			return ItemObject.ItemTypeEnum.Invalid;
		case WeaponClass.Dagger:
		case WeaponClass.OneHandedSword:
		case WeaponClass.OneHandedAxe:
		case WeaponClass.Mace:
			return ItemObject.ItemTypeEnum.OneHandedWeapon;
		case WeaponClass.TwoHandedSword:
		case WeaponClass.TwoHandedAxe:
		case WeaponClass.Pick:
		case WeaponClass.TwoHandedMace:
			return ItemObject.ItemTypeEnum.TwoHandedWeapon;
		case WeaponClass.OneHandedPolearm:
		case WeaponClass.TwoHandedPolearm:
		case WeaponClass.LowGripPolearm:
			return ItemObject.ItemTypeEnum.Polearm;
		case WeaponClass.Arrow:
			return ItemObject.ItemTypeEnum.Arrows;
		case WeaponClass.Bolt:
			return ItemObject.ItemTypeEnum.Bolts;
		case WeaponClass.SlingStone:
			return ItemObject.ItemTypeEnum.SlingStones;
		case WeaponClass.Cartridge:
			return ItemObject.ItemTypeEnum.Bullets;
		case WeaponClass.Bow:
			return ItemObject.ItemTypeEnum.Bow;
		case WeaponClass.Crossbow:
			return ItemObject.ItemTypeEnum.Crossbow;
		case WeaponClass.Sling:
			return ItemObject.ItemTypeEnum.Sling;
		case WeaponClass.Stone:
		case WeaponClass.Boulder:
		case WeaponClass.ThrowingAxe:
		case WeaponClass.ThrowingKnife:
		case WeaponClass.Javelin:
		case WeaponClass.BallistaBoulder:
		case WeaponClass.BallistaStone:
			return ItemObject.ItemTypeEnum.Thrown;
		case WeaponClass.Pistol:
			return ItemObject.ItemTypeEnum.Pistol;
		case WeaponClass.Musket:
			return ItemObject.ItemTypeEnum.Musket;
		case WeaponClass.SmallShield:
		case WeaponClass.LargeShield:
			return ItemObject.ItemTypeEnum.Shield;
		case WeaponClass.Banner:
			return ItemObject.ItemTypeEnum.Banner;
		default:
			return ItemObject.ItemTypeEnum.Invalid;
		}
	}

	public WeaponComponentData(ItemObject item, WeaponClass weaponClass = WeaponClass.Undefined, WeaponFlags weaponFlags = (WeaponFlags)0uL)
	{
		BodyArmor = 0;
		PhysicsMaterial = "";
		FlyingSoundCode = "";
		PassbySoundCode = "";
		ItemUsage = null;
		SwingSpeed = 0;
		ThrustSpeed = 0;
		MissileSpeed = 0;
		WeaponLength = 0;
		ThrustDamage = 0;
		SwingDamage = 0;
		AmmoOffset = Vec3.Zero;
		Accuracy = 0;
		StickingFrame = MatrixFrame.Identity;
		TrailParticleName = "";
		WeaponClass = weaponClass;
		WeaponFlags = weaponFlags;
		Frame = MatrixFrame.Identity;
		RotationSpeed = Vec3.Zero;
		ReloadPhaseCount = 0;
	}

	public void Deserialize(ItemObject item, XmlNode node)
	{
		BodyArmor = ((node.Attributes["body_armor"] != null) ? int.Parse(node.Attributes["body_armor"].Value) : 0);
		PhysicsMaterial = node.Attributes["physics_material"]?.Value;
		FlyingSoundCode = node.Attributes["flying_sound_code"]?.Value;
		PassbySoundCode = node.Attributes["passby_sound_code"]?.Value;
		ItemUsage = node.Attributes["item_usage"]?.Value;
		WeaponBalance = ((node.Attributes["weapon_balance"] != null) ? ((float)int.Parse(node.Attributes["weapon_balance"].Value) * 0.01f) : 0f);
		SwingSpeed = ((node.Attributes["speed_rating"] != null) ? int.Parse(node.Attributes["speed_rating"].Value) : 0);
		ThrustSpeed = ((node.Attributes["thrust_speed"] != null) ? int.Parse(node.Attributes["thrust_speed"].Value) : 0);
		MissileSpeed = ((node.Attributes["missile_speed"] != null) ? int.Parse(node.Attributes["missile_speed"].Value) : 0);
		WeaponLength = ((node.Attributes["weapon_length"] != null) ? int.Parse(node.Attributes["weapon_length"].Value) : 0);
		ThrustDamage = ((node.Attributes["thrust_damage"] != null) ? int.Parse(node.Attributes["thrust_damage"].Value) : 0);
		SwingDamage = ((node.Attributes["swing_damage"] != null) ? int.Parse(node.Attributes["swing_damage"].Value) : 0);
		FireDamage = ((node.Attributes["fire_damage"] != null) ? int.Parse(node.Attributes["fire_damage"].Value) : 0);
		Accuracy = ((node.Attributes["accuracy"] != null) ? int.Parse(node.Attributes["accuracy"].Value) : 100);
		ThrustDamageType = ((node.Attributes["thrust_damage_type"] != null) ? ((DamageTypes)Enum.Parse(typeof(DamageTypes), node.Attributes["thrust_damage_type"].Value)) : DamageTypes.Blunt);
		SwingDamageType = ((node.Attributes["swing_damage_type"] != null) ? ((DamageTypes)Enum.Parse(typeof(DamageTypes), node.Attributes["swing_damage_type"].Value)) : DamageTypes.Blunt);
		WeaponClass = ((node.Attributes["weapon_class"] != null) ? ((WeaponClass)Enum.Parse(typeof(WeaponClass), node.Attributes["weapon_class"].Value)) : WeaponClass.Undefined);
		AmmoClass = ((node.Attributes["ammo_class"] != null) ? ((WeaponClass)Enum.Parse(typeof(WeaponClass), node.Attributes["ammo_class"].Value)) : WeaponClass.Undefined);
		ReloadPhaseCount = (short)((node.Attributes["reload_phase_count"] == null) ? 1 : short.Parse(node.Attributes["reload_phase_count"].Value));
		CenterOfMass = (float)WeaponLength * 0.5f * 0.01f;
		CenterOfMass3D = ((node.Attributes["center_of_mass"] != null) ? Vec3.Parse(node.Attributes["center_of_mass"].Value) : Vec3.Zero);
		if (WeaponClass != WeaponClass.Bow && WeaponClass != WeaponClass.Crossbow && WeaponClass != WeaponClass.Sling && WeaponClass != WeaponClass.SmallShield && WeaponClass != WeaponClass.LargeShield && WeaponClass != WeaponClass.Arrow && WeaponClass != WeaponClass.Bolt && WeaponClass != WeaponClass.SlingStone && WeaponClass != WeaponClass.ThrowingKnife && WeaponClass != WeaponClass.ThrowingAxe && WeaponClass != WeaponClass.Javelin && WeaponClass != WeaponClass.Stone && WeaponClass != WeaponClass.Boulder && WeaponClass != WeaponClass.BallistaStone)
		{
			_ = WeaponClass;
			_ = 26;
		}
		XmlAttribute xmlAttribute = node.Attributes["ammo_limit"];
		XmlAttribute xmlAttribute2 = node.Attributes["stack_amount"];
		XmlAttribute xmlAttribute3 = node.Attributes["hit_points"];
		if (xmlAttribute != null)
		{
			MaxDataValue = short.Parse(xmlAttribute.Value);
		}
		else if (xmlAttribute2 != null)
		{
			MaxDataValue = short.Parse(xmlAttribute2.Value);
		}
		else if (xmlAttribute3 != null)
		{
			MaxDataValue = short.Parse(xmlAttribute3.Value);
		}
		else
		{
			MaxDataValue = 0;
		}
		Vec3 v = default(Vec3);
		Mat3 rot = Mat3.Identity;
		XmlNode xmlNode = node.Attributes["sticking_position"];
		if (xmlNode != null)
		{
			string[] array = xmlNode.Value.Split(new char[1] { ',' });
			if (array.Length == 3)
			{
				float.TryParse(array[0], out v.x);
				float.TryParse(array[1], out v.y);
				float.TryParse(array[2], out v.z);
			}
		}
		XmlNode xmlNode2 = node.Attributes["sticking_rotation"];
		if (xmlNode2 != null)
		{
			string[] array2 = xmlNode2.Value.Split(new char[1] { ',' });
			if (array2.Length == 3)
			{
				float.TryParse(array2[0], out var result);
				float.TryParse(array2[1], out var result2);
				float.TryParse(array2[2], out var result3);
				rot.RotateAboutSide(result.ToRadians());
				rot.RotateAboutUp(result2.ToRadians());
				rot.RotateAboutForward(result3.ToRadians());
			}
		}
		StickingFrame = new MatrixFrame(in rot, rot.TransformToParent(in v));
		Vec3 o = default(Vec3);
		Mat3 rot2 = Mat3.Identity;
		XmlNode xmlNode3 = node.Attributes["position"];
		if (xmlNode3 != null)
		{
			string[] array3 = xmlNode3.Value.Split(new char[1] { ',' });
			if (array3.Length == 3)
			{
				float.TryParse(array3[0], out o.x);
				float.TryParse(array3[1], out o.y);
				float.TryParse(array3[2], out o.z);
			}
		}
		XmlNode xmlNode4 = node.Attributes["rotation"];
		if (xmlNode4 != null)
		{
			string[] array4 = xmlNode4.Value.Split(new char[1] { ',' });
			if (array4.Length == 3)
			{
				float.TryParse(array4[0], out var result4);
				float.TryParse(array4[1], out var result5);
				float.TryParse(array4[2], out var result6);
				rot2.RotateAboutUp(result6.ToRadians());
				rot2.RotateAboutSide(result4.ToRadians());
				rot2.RotateAboutForward(result5.ToRadians());
			}
		}
		Frame = new MatrixFrame(in rot2, in o);
		RotationSpeed = ((node.Attributes["rotation_speed"] != null) ? Vec3.Parse(node.Attributes["rotation_speed"].Value) : Vec3.Zero);
		TrailParticleName = node.Attributes["trail_particle_name"]?.Value;
		foreach (XmlNode childNode in node.ChildNodes)
		{
			if (!(childNode.Name == "WeaponFlags"))
			{
				continue;
			}
			foreach (WeaponFlags value in Enum.GetValues(typeof(WeaponFlags)))
			{
				if (childNode.Attributes[value.ToString()] != null)
				{
					WeaponFlags |= value;
				}
			}
		}
		TotalInertia = (float)((!IsConsumable) ? 1 : MaxDataValue) * item.Weight * 0.05f;
		Handling = ThrustSpeed;
		SweetSpotReach = 0.93f;
		SetDamageFactors(item.Weight);
	}

	private void SetDamageFactors(float weight)
	{
		DamageTypes swingDamageType = SwingDamageType;
		if (WeaponClass == WeaponClass.Bow || WeaponClass == WeaponClass.Crossbow || WeaponClass == WeaponClass.ThrowingAxe || WeaponClass == WeaponClass.ThrowingKnife || WeaponClass == WeaponClass.Javelin || WeaponClass == WeaponClass.Arrow || WeaponClass == WeaponClass.Bolt)
		{
			SwingDamageFactor = 1f;
			ThrustDamageFactor = 1f;
			return;
		}
		float num = TaleWorlds.Library.MathF.Sqrt(TaleWorlds.Library.MathF.Sqrt(weight / ((float)WeaponLength * 0.01f)));
		float num2 = 0f;
		switch (swingDamageType)
		{
		case DamageTypes.Blunt:
			num *= 1f;
			num2 = 1f;
			break;
		case DamageTypes.Cut:
			num *= 0.8f;
			num2 = 0.5f;
			break;
		case DamageTypes.Pierce:
			num *= 0.7f;
			num2 = 0.4f;
			break;
		}
		num *= 0.8f;
		num2 = (SwingDamageFactor = num2 * 0.8f);
		ThrustDamageFactor = num2;
	}

	public float GetRealWeaponLength()
	{
		return (float)WeaponLength * 0.01f + Vec3.DotProduct(Frame.rotation.u, Frame.origin);
	}

	public MatrixFrame GetMissileStartingFrame()
	{
		MatrixFrame identity = default(MatrixFrame);
		if (WeaponClass == WeaponClass.Arrow || WeaponClass == WeaponClass.Bolt || WeaponClass == WeaponClass.SlingStone)
		{
			Mat3 rotation = new Mat3(1f, 0f, 0f, 0f, 0f, -1f, 0f, 1f, 0f);
			identity.rotation = rotation;
			identity.origin = Vec3.Zero;
		}
		else
		{
			identity = MatrixFrame.Identity;
			if (WeaponClass == WeaponClass.ThrowingAxe)
			{
				identity.rotation.RotateAboutUp(-System.MathF.PI / 2f);
			}
			else if (WeaponClass == WeaponClass.ThrowingKnife)
			{
				identity.rotation.RotateAboutUp(-System.MathF.PI / 2f);
			}
			else
			{
				Mat3 rotation2 = new Mat3(1f, 0f, 0f, 0f, 0f, -1f, 0f, 1f, 0f);
				identity.rotation = rotation2;
			}
		}
		return identity;
	}
}
