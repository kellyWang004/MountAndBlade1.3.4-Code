using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core;

public class MBFastRandom
{
	private const ulong InitialHash = 14695981039346656037uL;

	private const ulong Prime = 1099511628211uL;

	private const double RealUnitInt = 4.656612873077393E-10;

	private const double RealUnitUint = 2.3283064365386963E-10;

	private const int FloatUnitRangeMax = 16777215;

	private const float FloatUnitInt = 5.9604645E-08f;

	[SaveableField(1)]
	private uint _x;

	[SaveableField(2)]
	private uint _y;

	[SaveableField(3)]
	private uint _z;

	[SaveableField(4)]
	private uint _w;

	internal static void AutoGeneratedStaticCollectObjectsMBFastRandom(object o, List<object> collectedObjects)
	{
		((MBFastRandom)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
	}

	internal static object AutoGeneratedGetMemberValue_x(object o)
	{
		return ((MBFastRandom)o)._x;
	}

	internal static object AutoGeneratedGetMemberValue_y(object o)
	{
		return ((MBFastRandom)o)._y;
	}

	internal static object AutoGeneratedGetMemberValue_z(object o)
	{
		return ((MBFastRandom)o)._z;
	}

	internal static object AutoGeneratedGetMemberValue_w(object o)
	{
		return ((MBFastRandom)o)._w;
	}

	public MBFastRandom()
		: this((uint)Environment.TickCount)
	{
	}

	public MBFastRandom(uint seed)
	{
		GenerateState(seed, out _x, out _y, out _z, out _w);
	}

	public void SetSeed(uint seed, uint seed2)
	{
		GenerateState(seed, seed2, out _x, out _y, out _z, out _w);
	}

	public int Next()
	{
		uint num;
		do
		{
			num = XorShift(ref _x, ref _y, ref _z, ref _w);
			num &= 0x7FFFFFFF;
		}
		while (num == int.MaxValue);
		return (int)num;
	}

	public int Next(int maxValue)
	{
		if (maxValue < 0)
		{
			throw new ArgumentOutOfRangeException("maxValue", "Maximum value must be non-negative.");
		}
		uint num = XorShift(ref _x, ref _y, ref _z, ref _w);
		return (int)(4.656612873077393E-10 * (double)(int)(0x7FFFFFFF & num) * (double)maxValue);
	}

	public int Next(int minValue, int maxValue)
	{
		if (minValue > maxValue)
		{
			throw new ArgumentOutOfRangeException("maxValue", maxValue, "Maximum value must be greater than or equal to minimum value");
		}
		uint num = XorShift(ref _x, ref _y, ref _z, ref _w);
		int num2 = maxValue - minValue;
		if (num2 < 0)
		{
			return minValue + (int)(2.3283064365386963E-10 * (double)num * (double)((long)maxValue - (long)minValue));
		}
		return minValue + (int)(4.656612873077393E-10 * (double)(int)(0x7FFFFFFF & num) * (double)num2);
	}

	public double NextDouble()
	{
		uint num = XorShift(ref _x, ref _y, ref _z, ref _w);
		return 4.656612873077393E-10 * (double)(int)(0x7FFFFFFF & num);
	}

	public float NextFloat()
	{
		uint num = XorShift(ref _x, ref _y, ref _z, ref _w);
		return 5.9604645E-08f * (float)(int)(0xFFFFFF & num);
	}

	public float NextFloatRanged(float minVal, float maxVal)
	{
		return minVal + NextFloat() * (maxVal - minVal);
	}

	public void NextBytes(byte[] buffer)
	{
		int num = 0;
		int num2 = buffer.Length - 3;
		while (num < num2)
		{
			uint num3 = XorShift(ref _x, ref _y, ref _z, ref _w);
			buffer[num++] = (byte)num3;
			buffer[num++] = (byte)(num3 >> 8);
			buffer[num++] = (byte)(num3 >> 16);
			buffer[num++] = (byte)(num3 >> 24);
		}
		if (num >= buffer.Length)
		{
			return;
		}
		uint num4 = XorShift(ref _x, ref _y, ref _z, ref _w);
		buffer[num++] = (byte)num4;
		if (num >= buffer.Length)
		{
			return;
		}
		buffer[num++] = (byte)(num4 >> 8);
		if (num < buffer.Length)
		{
			buffer[num++] = (byte)(num4 >> 16);
			if (num < buffer.Length)
			{
				buffer[num] = (byte)(num4 >> 24);
			}
		}
	}

	internal static int GetRandomInt(uint seed, uint seed2)
	{
		GenerateState(seed, seed2, out var x, out var y, out var z, out var w);
		uint num;
		do
		{
			num = XorShift(ref x, ref y, ref z, ref w);
			num &= 0x7FFFFFFF;
		}
		while (num == int.MaxValue);
		return (int)num;
	}

	internal static float GetRandomFloat(uint seed, uint seed2)
	{
		GenerateState(seed, seed2, out var x, out var y, out var z, out var w);
		uint num = XorShift(ref x, ref y, ref z, ref w);
		return 5.9604645E-08f * (float)(int)(0xFFFFFF & num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint XorShift(ref uint x, ref uint y, ref uint z, ref uint w)
	{
		uint num = x ^ (x << 11);
		x = y;
		y = z;
		z = w;
		w = w ^ (w >> 19) ^ (num ^ (num >> 8));
		return w;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void GenerateState(uint seed, out uint x, out uint y, out uint z, out uint w)
	{
		x = CalculateHashFromSeed(14695981039346656037uL, seed);
		y = CalculateHashFromSeed(14695981039346656037uL, x);
		z = CalculateHashFromSeed(x, y);
		w = CalculateHashFromSeed(y, z);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void GenerateState(uint seed, uint seed2, out uint x, out uint y, out uint z, out uint w)
	{
		uint seed3 = CalculateHashFromSeed(CalculateHashFromSeed(14695981039346656037uL, seed), seed2);
		x = CalculateHashFromSeed(14695981039346656037uL, seed3);
		y = CalculateHashFromSeed(14695981039346656037uL, x);
		z = CalculateHashFromSeed(x, y);
		w = CalculateHashFromSeed(y, z);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint CalculateHashFromSeed(ulong inputHash, uint seed)
	{
		return (uint)((inputHash ^ seed) * 1099511628211L >> 17);
	}
}
